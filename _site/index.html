<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>3行代码</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="/css/fontawesome/css/font-awesome.min.css ">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/">
    <link rel="alternate" type="application/rss+xml" title="3行代码" href="http://localhost:4000/feed.xml ">


<script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
     var hm = document.createElement("script");
     hm.src = "//hm.baidu.com/hm.js?d9432112fb859bf7276f8399641fb0c5";
     var s = document.getElementsByTagName("script")[0];
     s.parentNode.insertBefore(hm, s);
     })();
    </script>




    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-85978943-1', 'auto');
      ga('send', 'pageview');

    </script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">3行代码</a>
        <small>技术博客</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                
                <li>
                    
                    <a class="active" href="/">
                        
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>


                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to 3code.info!</h1>
        <small>记录生活</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/02/07/AD-Fastlane/">自动化测试部署系列 - Fastlane的黑魔法:自动打包编译上传 AppStore</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-02-07
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#AD" title="Category: AD" rel="category">AD</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#fastlane" title="Tag: fastlane" rel="tag">fastlane</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#fastlane-" id="markdown-toc-fastlane-">Fastlane 简介</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">1.主要使用场:</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">2.工具集</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">3.常见命令</a></li>
    </ul>
  </li>
  <li><a href="#fastlane--1" id="markdown-toc-fastlane--1">fastlane 入门实战</a>    <ul>
      <li><a href="#fastlane" id="markdown-toc-fastlane">1.安装 fastlane</a>        <ul>
          <li><a href="#app-id" id="markdown-toc-app-id">1.1 创建App ID\描述文件</a></li>
          <li><a href="#section-3" id="markdown-toc-section-3">1.2 安装</a></li>
          <li><a href="#fastlane-1" id="markdown-toc-fastlane-1">1.3 为项目配置 fastlane</a></li>
        </ul>
      </li>
      <li><a href="#fastlane--2" id="markdown-toc-fastlane--2">2.fastlane 文件配置</a>        <ul>
          <li><a href="#metadata-" id="markdown-toc-metadata-">2.1 配置 metadata 文件夹</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2.2 配置证书</a></li>
          <li><a href="#fastlane--itc" id="markdown-toc-fastlane--itc">2.3 将 fastlane 本地配置上传至 ITC</a></li>
        </ul>
      </li>
      <li><a href="#xcode-" id="markdown-toc-xcode-">3.Xcode 配置</a></li>
      <li><a href="#snapshot--xctest" id="markdown-toc-snapshot--xctest">4.Snapshot 截图和 XCTest</a></li>
      <li><a href="#ipa-" id="markdown-toc-ipa-">5.创建 IPA 文件</a></li>
      <li><a href="#ipa--itc" id="markdown-toc-ipa--itc">6.上传 IPA 文件到 ITC</a></li>
      <li><a href="#deliverfile" id="markdown-toc-deliverfile">7.配置 Deliverfile</a></li>
      <li><a href="#appstore-" id="markdown-toc-appstore-">8.提交 AppStore 审核</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">9.使用一键命令</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">10.参考</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>有关神器 Fastlane 持续集成\部署的文章网上挺多,本文定位是入门教程,针对 iOS 应用的持续部署,<strong>只需一条命令就可实现从 Xcode 项目到 编译\打包\构建\提交审核</strong></p>

  <p>文章稍微有点长,涵盖内容为:fastlane 简介\安装\配置 + Snapshot 截图 + XCTest + 一键上传App Store</p>

  <p>说明:本文将 Apple Dev Center 简称为 ADC; iTunes Connect 简称为 ITC</p>

</blockquote>

<ul>
  <li>首发文章及代码请<a href="https://github.com/mythkiven/AD_Fastlane">戳一下</a></li>
  <li>先放图看 fastlane 实现自动上传功能:</li>
</ul>

<p>进度:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/08/589a9ef7823dc.png" alt="" /></p>

<p>提交成功,等待审核
<img src="https://ooo.0o0.ooo/2017/02/08/589aaed07d991.png" alt="" /></p>

<h2 id="fastlane-">Fastlane 简介</h2>

<p>fastlane 是一个完全开源的项目,包含一组 Ruby 实现的工具集,能完成 iOS 和 Android 工程 的自动化构建\测试和发布等功能,<a href="https://krausefx.com/blog/fastlane-is-now-part-of-fabric">现被Twitter收购,是Fabric的一部分</a>.fastlane 强大之处就在于其提供的工具全,基本可以覆盖打包测试发布的所有流程,如下图:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/08/589ace59a6210.png" alt="" /></p>

<p>fastlane 的每一个工具都对应一个 Ruby 脚本,用来执行某一特定的任务,而最妙的是可以通过配置文件将不同的工具灵活的结合在一起,从而形成一个完整的自动化流程,实现一键上传 ITC,从而缩短用于构建发布的时间.</p>

<h5 id="section">1.主要使用场:</h5>

<ul>
  <li>提交时执行测试（包括单元测试和集成测试）</li>
  <li>构建并分发内部测试\公开测试版本</li>
  <li>构建生产版本并上传至 ITC（包括更新配置文件,创建新的屏幕截图,上传应用并提交审核）</li>
  <li>…</li>
</ul>

<h5 id="section-1">2.工具集</h5>

<p>fastlane 将如下的工具套件有机地结合起来,从管理证书到单元测试,从编译打包到上传发布,都能通过命令行轻松完成.该套件支持与 Jenkins 和 CocoaPods,xctools 等其他第三方工具的集成,并且能够定义多个通道（lanes）以支持不同的部署目标.</p>

<ul>
  <li>deliver: 将应用在 ITC 上所需数据提交至 ITC (包括:截图,配置文件,ipa包)</li>
  <li>snapshot: 依靠 UI Test 完成截图</li>
  <li>frameit: 快速地把应用截图放入设备框里</li>
  <li>pem: 可以自动化地生成和更新应用推送通知描述文件</li>
  <li>sigh: 创建\更新\下载和修复 provisioning profiles,支持App Store, Ad Hoc, Development和企业profiles</li>
  <li>gym: 编译\打包iOS app,生成签名的ipa文件</li>
  <li>…</li>
</ul>

<h5 id="section-2">3.常见命令</h5>

<p>fastlane 命令中,个人觉得下面两个较为常用:</p>

<ul>
  <li>列出所有的 fastlane 的 actions:</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane actions
</code></pre>
</div>

<ul>
  <li>fastlane action [action_name]: 显示某一个 action 的详细配置</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>$  fastlane action match
</code></pre>
</div>

<h2 id="fastlane--1">fastlane 入门实战</h2>

<h3 id="fastlane">1.安装 fastlane</h3>

<h5 id="app-id">1.1 创建App ID\描述文件</h5>

<ul>
  <li>本教程目标是上传 ITC ,因此需要提前在 ADC 和 ITC 中创建 App ID\描述文件\App</li>
  <li>这里使用的项目是 AD Demo,代码见 <a href="https://github.com/mythkiven/AD_Fastlane">GitHub</a></li>
</ul>

<p><img src="https://ooo.0o0.ooo/2017/02/06/589845eaa299d.png" alt="" />
<img src="https://ooo.0o0.ooo/2017/02/06/589847204b77a.png" alt="" /></p>

<h5 id="section-3">1.2 安装</h5>

<p>查看 Ruby 版本,低于2.0最好升级</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ruby -v
</code></pre>
</div>

<p>检查 Xcode CLT 是否安装</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ xcode-select --install
</code></pre>
</div>

<p>安装 fastlane</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ sudo gem install -n /usr/local/bin fastlane
</code></pre>
</div>

<p>检查版本 fastlane</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane --version
fastlane installation at path:
/Library/Ruby/Gems/2.0.0/gems/fastlane-2.14.2/bin/fastlane
-----------------------------
fastlane 2.14.2
</code></pre>
</div>

<p>OK,安装完成</p>

<h5 id="fastlane-1">1.3 为项目配置 fastlane</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cd 项目目录
$ fastlane init
</code></pre>
</div>

<p>如果期间报错 <code class="highlighter-rouge">Connection reset by peer - SSL_Connect</code>,就需要执行:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ brew update &amp;&amp; brew install ruby
// 重装
$ sudo gem install -n /usr/local/bin fastlane
</code></pre>
</div>

<p>然后重新执行</p>
<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane init
</code></pre>
</div>

<ul>
  <li>期间会让你输入 Apple ID 账号密码(这个信息会存在钥匙串中,后续使用无需再输入密码)</li>
  <li>会检测当前的 app identifier 是否在  ADC 中</li>
  <li>会检测当前 app 是否在 ITC 中</li>
  <li>如果已经在 ADC 和 ITC 中创建相应的信息,那么过程会很顺利,如下图:</li>
</ul>

<p><img src="https://ooo.0o0.ooo/2017/02/07/58992aea708c6.png" alt="" /></p>

<p>并在 Xcode 项目目录中生成如下文件:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/07/58992b1016443.png" alt="" /></p>

<p>注意:如果没有在 ITC 中创建 App ,也就不会创建上述两个文件夹;当然也可以后续创建,执行如下操作即可:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane produce init
</code></pre>
</div>

<h3 id="fastlane--2">2.fastlane 文件配置</h3>

<p>fastlane 的各文件解释如下:</p>

<ul>
  <li>Appfile:用于存储应用程序标识符和Apple ID 等信息</li>
  <li>Fastfile:配置管理 lane</li>
  <li>Deliverfile:配置应用在 ITC 中的各种信息,和 ICC 中的数据是一一对应的</li>
  <li>metadata:包含应用在 ITC 中的各种信息</li>
  <li>screenshots:包含截图数据</li>
</ul>

<p>需要注意的是,metadata 和 Deliverfile,都可以配置 ITC 的数据,但后者优先级高.正如下图:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/08/589aba7c0b998.png" alt="" /></p>

<p><img src="https://ooo.0o0.ooo/2017/02/08/589aba7c1d252.png" alt="" /></p>

<p>下文先在 metadata 文件夹中进行配置用于演示,在文末会删除 metadata 中的配置文本,全部配置在 Deliverfile 中.</p>

<h5 id="metadata-">2.1 配置 metadata 文件夹</h5>

<p>修改 App 描述:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ cd metadata 
$ cd zh-Hans
$ vim description.txt
</code></pre>
</div>

<p>修改关键字:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ vim keywords.txt
</code></pre>
</div>

<p>修改 support_url:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ vim support_url.txt
</code></pre>
</div>

<p>修改 copyright:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ vim copyright.txt
</code></pre>
</div>

<p>等等,其他信息的修改类似.</p>

<p>然后创建分级文件:itunes_rating_config.json,这个和 ICC 中的分级是对应的.</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="nt">"CARTOON_FANTASY_VIOLENCE"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"REALISTIC_VIOLENCE"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> 
</span><span class="nt">"PROLONGED_GRAPHIC_SADISTIC_REALISTIC_VIOLENCE"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"PROFANITY_CRUDE_HUMOR"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"MATURE_SUGGESTIVE"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> 
</span><span class="nt">"HORROR"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="nt">"MEDICAL_TREATMENT_INFO"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"ALCOHOL_TOBACCO_DRUGS"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> 
</span><span class="nt">"GAMBLING"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> 
</span><span class="nt">"SEXUAL_CONTENT_NUDITY"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"GRAPHIC_SEXUAL_CONTENT_NUDITY"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> 
</span><span class="nt">"UNRESTRICTED_WEB_ACCESS"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nt">"GAMBLING_CONTESTS"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>此处配置参见<a href="https://github.com/fastlane/fastlane/blob/master/deliver/Reference.md">官方文档</a></p>

<p>然后将 App 图标添加至文件夹中,接下来要创建证书:</p>

<h5 id="section-4">2.2 配置证书</h5>

<p>修改 Fastfile:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ vim Fastfile
</code></pre>
</div>

<p>修改内容如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>fastlane_version "2.14.2"

default_platform :ios

platform :ios do
 
  # 当前任务的描述
  desc "Creating a code signing certificate and provisioning profile"
  # 任务名称
  lane :provision do
    # 创建 ITC 中的 App 信息
    produce(
      app_name: 'AD_Demo',
      language: 'zh-Hans',
      app_version: '1.0',
      sku: 'com.3code.ADDemo.Test'
    )
    # 使用证书创建私钥及签名
    cert
    # 每次运行时创建新的配置文件
    sigh(force: true)
  end
 
  error do |lane, exception|
  
  end
  
end
</code></pre>
</div>

<p>如果想创建 ad hoc 配置文件,需要指定sigh(adhoc: true).更多的信息参见:</p>

<ul>
  <li><a href="https://github.com/fastlane/fastlane/tree/master/fastlane/docs">官方文档</a></li>
  <li><a href="https://docs.fastlane.tools/actions/">fastlane actions</a></li>
</ul>

<h5 id="fastlane--itc">2.3 将 fastlane 本地配置上传至 ITC</h5>

<p>重新进入项目目录,执行如下操作:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane provision
</code></pre>
</div>

<p>等待一小会儿,终端提示成功创建证书配置:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>fastlane.tools finished successfully 🎉
</code></pre>
</div>

<p>打开 ICC 网页,会发现本地的配置,已经成功上传.</p>

<h3 id="xcode-">3.Xcode 配置</h3>

<p>xcode 配置也简单,只需要将项目修改至生产状态即可(描述文件).其它像构建版本号之类的不用理会, fastlane 会处理的.</p>

<h3 id="snapshot--xctest">4.Snapshot 截图和 XCTest</h3>

<p>snapshot 需要和 XCTest 配合使用,关于 XCTest,我的博客中<a href="www.3code.info/2017/01/23/AD-XCTest/">有一篇文章</a>做了简单介绍.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane snapshot init
</code></pre>
</div>

<p>目录中会生成一个 Snapfile 文件,用于配置截图信息,修改内容如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 图片尺寸
devices([
  "iPhone 5",
  "iPhone 6",
  "iPhone 6 Plus"
])
 
# 支持语言
languages([
  'zh-Hans'
])
 
# 储存位置
output_directory "./fastlane/screenshots"
 
# 删除之前图片
clear_previous_screenshots true
</code></pre>
</div>

<p>然后打开 Xcode 工程,添加截图设置(需要增加 UI Test, 因为截图是在 UI Test 时截取的):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>\\ 1）在项目添加UI测试,已经添加略过
\\ 2）将./fastlane/SnapshotHelper.swift 添加到UI测试中
\\ 3）打开 AD_DemoUITests.swift ,删除setUp和tearDown方法，然后在其中添加以下代码testExample：
 
  let app = XCUIApplication()
  setupSnapshot(app)
  app.launch()
  
  app.buttons["next"].tap()
  snapshot("01firstPage") // 此处截图
  
  app.buttons["back"].tap()
  snapshot("02secondPage") // 此处截图

</code></pre>
</div>

<p>打开 Fastfile ,并添加如下信息,用于配置截图</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  desc "Take screenshots"
  lane :screenshot do
    snapshot
  end
</code></pre>
</div>

<p>执行 <code class="highlighter-rouge">$ fastlane screenshot</code>, fastlane 会自动调用模拟器,执行测试并生成快照,可能会由于模拟器启动慢而导致时间稍微有点长.</p>

<p>成功截图的提示:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/07/58995745a83cd.png" alt="" /></p>

<h3 id="ipa-">5.创建 IPA 文件</h3>

<p>打开 fastfile,加入如下代码,配置创建 ipa</p>

<div class="highlighter-rouge"><pre class="highlight"><code>desc "Create ipa"
  lane :build do
    increment_build_number
    gym
  end
</code></pre>
</div>

<p>保存并执行如下操作,将自动创建 IPA 包</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane build
</code></pre>
</div>

<p>如果出现错误: <code class="highlighter-rouge">There does not seem to be a CURRENT_PROJECT_VERSION key set for this project.  Add this key to your target's expert build settings.</code>
<a href="https://developer.apple.com/library/content/qa/qa1827/_index.html">请查阅此处</a></p>

<p>这是一个自动增加构建版本号的设置,需要手动修改.</p>

<h3 id="ipa--itc">6.上传 IPA 文件到 ITC</h3>

<p>打开 Fastfile ,添加如下代码:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>desc "Upload to App Store"
  lane :upload do
    deliver
  end
</code></pre>
</div>

<p>然后执行命令,上传到 ITC :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane upload
</code></pre>
</div>

<p>期间,会创建一个 html 形式的预览文件,确认没问题输入 y;</p>

<p>当然最有可能的错误就是网络链接的问题: <code class="highlighter-rouge">Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443.</code> 重新配置代理即可.</p>

<h3 id="deliverfile">7.配置 Deliverfile</h3>

<p>其实上传 ITC 最主要的文件是 Deliverfile,配置好 Deliverfile 后,可以删除 metadata 文件夹中的文本配置.最终配置如下图:</p>

<p><img src="https://ooo.0o0.ooo/2017/02/08/589ac0ac8d172.png" alt="" /></p>

<p>以下是主要的配置,更多更详细的<a href="https://github.com/mythkiven/AD_Fastlane/blob/master/AD_Demo/fastlane/Deliverfile">请戳文件</a>,里面有详细的注释,拿来即可使用</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
# 1 app_identifier
app_identifier "com.3code.ADDemo"

# 2 用户名,Apple ID电子邮件地址
username "Apple ID电子邮件地址"  

# 3 支持语言
supportedLanguages = {
  "cmn-Hans" =&gt; "zh-Hans"
}

# 4 app 名称
name({
'zh-Hans' =&gt; "ADDemo"
})

# 5 描述
description({
  'zh-Hans' =&gt; "简体中文版"
})

# 6 提交审核信息
submission_information({    
    export_compliance_encryption_updated: false,
    export_compliance_uses_encryption: false,
    content_rights_contains_third_party_content: false,
    add_id_info_uses_idfa: false
})

# 7 应用审核小组的联系信息 app 审核信息
app_review_information(
  first_name: "name",
  last_name: "name",
  phone_number: "手机号",
  email_address: "email",
  demo_user: "测试账号用户名",
  demo_password: "测试账号密码",
  notes: "noting"
)

# 8 copyright 
copyright "#{Time.now.year} 3code"

# 
</code></pre>
</div>

<h3 id="appstore-">8.提交 AppStore 审核</h3>

<p>继续打开 Fastfile,修改如下代码:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>desc "Upload to App Store and submit for review"
  lane :upload do
    deliver(
      submit_for_review: true
    )
  end
</code></pre>
</div>

<p>然后执行命令,提交审核 :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane upload
</code></pre>
</div>

<h3 id="section-5">9.使用一键命令</h3>

<p>添加如下的代码,可以一步搞定所有的操作:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>desc "Provision, take screenshots, build and upload to App Store"
  lane :do_everything do
    provision
    screenshot
    build
    upload
  end
</code></pre>
</div>

<p>对应的命令是:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ fastlane do_everything
</code></pre>
</div>

<ul>
  <li>
    <p>本文只是简单的介绍了 fastlane 的使用,更多的资料还请参考文末的链接</p>
  </li>
  <li>
    <p>如果你对 ITC 不了解,或者很少发布 App ,建议看看官方文档,要知道发布 App 也有<a href="https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_SCh/Appendices/Properties.html">官方指南哦</a></p>
  </li>
  <li>
    <p>本文是系列文章,后续文章会陆续在这里以及我的<a href="www.3code.info">博客</a>中发布,喜欢请给个✨吧</p>
  </li>
</ul>

<h3 id="section-6">10.参考</h3>

<ul>
  <li><a href="https://fastlane.tools/">官网</a></li>
  <li><a href="https://github.com/fastlane/fastlane">github</a></li>
  <li><a href="https://docs.fastlane.tools/getting-started/ios/setup/">文档</a></li>
</ul>

<p>最后给点小建议:如果遇到错误首选就是查 issues,你遇到的问题,基本前人都遇到过了.我能在2天里快速入门 fastlane 全靠看 issues 😁😁</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/02/07/AD-Fastlane/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/01/23/AD-XCTest/">自动化测试部署系列 - XCTest入门</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-01-23
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#AD" title="Category: AD" rel="category">AD</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#XCTest" title="Tag: XCTest" rel="tag">XCTest</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">简述</a></li>
  <li><a href="#ui-testing--accessibility" id="markdown-toc-ui-testing--accessibility">UI Testing 和 Accessibility</a></li>
  <li><a href="#demo" id="markdown-toc-demo">demo</a></li>
</ul>

<h3 id="section">简述</h3>

<blockquote>
  <p>本文是自动化测试部署系列的文章,后续会有更多相关文章</p>
</blockquote>

<p>关于 UI 测试,在 iOS 的开源社区有过一系列的尝试,比如 KIF 框架,Apple 自己的 Automating UI Testing 或者 Facebook 的截图测试等.这些方法有一个共同的特点,那就是配置起来十分繁琐,使用上也有诸多不便.这大概也是 UI 测试所面临的最大窘境 – 往往开发者在一个项目里写了一两个 UI 测试用例后,就会觉得难以维护,怯于巨大的时间成本,继而放弃.</p>

<p>Apple 在 Xcode 7 中新加入了一套 UI Testing 的工具,其目的就是解决这个问题.新的 UI Testing 比以往的解决方案要简单不少,特别是在创建测试用例的时候更集成了录制的功能,这有希望让 UI Testing 变得更为普及.</p>

<h3 id="ui-testing--accessibility">UI Testing 和 Accessibility</h3>

<p>在 iOS 中使用 XCTest, 就必须要了解 Accessibility. UI Accessibility 早在 iOS 3.0 就被引入了,用来辅助身体不便的人士使用 app.VoiceOver 是 Apple 的屏幕阅读技术,而 UI Accessibility 的基本原则就是对屏幕上的 UI 元素进行分类和标记.两者配合,通过阅读或者聆听这些元素,用户就可以在不接触屏幕的情况下通过声音来使用 app.</p>

<p>Accessibility 的核心思想是对 UI 元素进行分类和标记 – 将屏幕上的 UI 分类为像是按钮,文本框,cell 或者是静态文本 (也就是 label) 这样的类型,然后使用 identifier 来区分不同的 UI 元素.用户可以通过语音控制 app 的按钮点击,或是询问某个 label 的内容等等,十分方便.iOS SDK 中的控件都实现了默认的 Accessibility 支持,而我们如果使用自定义的控件的话,则需要自行使用 Accessibility 的 API 来进行添加.</p>

<p>UI 测试的本质就是定位在屏幕上的元素,实现一些像是点击或者拖动这样的操作交互,然后获取 UI 的状态进行断言来判断是否符合我们的预期.这个过程及其需求与 Accessibility 的功能是高度吻合的.这也是为什么 iOS 中大部分的 UI 测试框架都是基于 UI Accessibility 的原因, UI Testing 也不例外.</p>

<h3 id="demo">demo</h3>

<p>demo 比较简单,主要用于演示基本的流程,代码在 GitHub 中.</p>

<p>相比起其他一些 UI 测试框架,Xcode 的 UI Testing 最为诱人的优点在于可以直接录制操作.新建一个 XCTest,默认实现如下:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">XCTest</span>

<span class="kd">class</span> <span class="kt">UITESTUITests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
        
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">setUp</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">setUp</span><span class="p">()</span>
        
        <span class="n">continueAfterFailure</span> <span class="o">=</span> <span class="kc">false</span>
        
        <span class="c1">// launch 方法来启动测试 app</span>
        <span class="c1">// XCUIApplication 是 UIApplication 在测试进程中的代理 (proxy)</span>

        <span class="kt">XCUIApplication</span><span class="p">()</span><span class="o">.</span><span class="nf">launch</span><span class="p">()</span> 

    <span class="p">}</span>
    
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">tearDown</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">tearDown</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">testExample</span><span class="p">()</span> <span class="p">{</span>
        
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre>
</div>

<p>使用的方法是,先创建一个测试方法,然后将光标停留在方法中,然后点击录制.和 app 的交互就会被自动转写成代码.</p>

<p><img src="https://ooo.0o0.ooo/2017/02/06/5898158326f72.png" alt="" /></p>

<p>操作是:</p>
<ul>
  <li>2次点击 “color” 按钮 ,改变背景色</li>
  <li>点击”下一页”按钮 push 到第二页</li>
  <li>点击”back” 按钮 pop 回第一页</li>
</ul>


                </div>
                <div class="read-all">
                    <a  href="/2017/01/23/AD-XCTest/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/01/18/SDiffuseMenu/">Swift 版 AwesomeMenu 的改写之旅:SDiffuseMenu</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-01-18
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#SDiffuseMenu" title="Tag: SDiffuseMenu" rel="tag">SDiffuseMenu</a>&nbsp;
    
        <a href="/tag/#Animation" title="Tag: Animation" rel="tag">Animation</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、使用方法：</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、添加协议</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、设置菜单的选项按钮数据</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">3、设置菜单按钮</a></li>
      <li><a href="#sdiffusemenu" id="markdown-toc-sdiffusemenu">4、添加 SDiffuseMenu</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">5、动画配置</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">6、动画过程监听</a></li>
    </ul>
  </li>
  <li><a href="#swift" id="markdown-toc-swift">二、Swift转写之旅</a>    <ul>
      <li><a href="#capropertyanimation" id="markdown-toc-capropertyanimation">1、CAPropertyAnimation动画</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">2、动画分析</a>        <ul>
          <li><a href="#section-7" id="markdown-toc-section-7">2.1、单个选项关闭动画分析：</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">2.2、整体动画的控制</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>本动画是 Swift 版的 AwesomeMenu,如需OC版还请移步<a href="https://github.com/levey/AwesomeMenu">这里</a>。</p>

  <p>SDiffuseMenu 当前版本 V1.2.1,代码<a href="https://github.com/mythkiven/DiffuseMenu_Swift">请戳这里</a></p>

  <p>SDiffuseMenu 嵌入 pod ‘SDiffuseMenu’, ‘~&gt; 1.2.1’</p>

</blockquote>

<p><strong>动画效果如下:</strong></p>

<p><img src="https://raw.githubusercontent.com/mythkiven/DiffuseMenu_Swift/master/Source/SDiffuseMenu.gif" alt="" /></p>

<p><strong>配置图如下:</strong></p>

<p><img src="https://raw.githubusercontent.com/mythkiven/DiffuseMenu_Swift/master/Source/settingAngle.png" alt="" /></p>

<h2 id="section">一、使用方法：</h2>

<p>添加协议(动画状态回调) -&gt; 设置选项数组 -&gt; 设置菜单按钮 -&gt; 动画属性配置 -&gt; .addSubview(menu)</p>

<h4 id="section-1">1、添加协议</h4>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span><span class="p">,</span> <span class="kt">SDiffuseMenuDelegate</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="o">!</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="section-2">2、设置菜单的选项按钮数据</h4>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 加载图片</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">storyMenuItemImage</span>            <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"menuitem-normal.png"</span><span class="p">)</span>         <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">storyMenuItemImagePressed</span>     <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"menuitem-highlighted.png"</span><span class="p">)</span>    <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">starImage</span>                     <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"star.png"</span><span class="p">)</span>                    <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">starItemNormalImage</span>           <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"addbutton-normal.png"</span><span class="p">)</span>        <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">starItemLightedImage</span>          <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"addbutton-highlighted.png"</span><span class="p">)</span>   <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">starItemContentImage</span>          <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"plus-normal.png"</span><span class="p">)</span>             <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">guard</span> <span class="k">let</span> <span class="nv">starItemContentLightedImage</span>   <span class="o">=</span>  <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span><span class="s">"plus-highlighted.png"</span><span class="p">)</span>        <span class="k">else</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"图片加载失败"</span><span class="p">)</span> <span class="p">}</span>

<span class="k">var</span> <span class="nv">menus</span> <span class="o">=</span> <span class="p">[</span><span class="kt">SDiffuseMenuItem</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="mi">6</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">starMenuItem</span> <span class="o">=</span>  <span class="kt">SDiffuseMenuItem</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="n">storyMenuItemImage</span><span class="p">,</span>
                                         <span class="nv">highlightedImage</span><span class="p">:</span> <span class="n">storyMenuItemImagePressed</span><span class="p">,</span> 
                                         <span class="nv">contentImage</span><span class="p">:</span> <span class="n">starImage</span><span class="p">,</span>
                                         <span class="nv">highlightedContentImage</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="n">menus</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">starMenuItem</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="section-3">3、设置菜单按钮</h4>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">startItem</span> <span class="o">=</span> <span class="kt">SDiffuseMenuItem</span><span class="p">(</span><span class="nv">image</span><span class="p">:</span> <span class="n">starItemNormalImage</span><span class="p">,</span>
                                 <span class="nv">highlightedImage</span><span class="p">:</span> <span class="n">starItemLightedImage</span><span class="p">,</span>
                                 <span class="nv">contentImage</span><span class="p">:</span> <span class="n">starItemContentImage</span><span class="p">,</span>
                                 <span class="nv">highlightedContentImage</span><span class="p">:</span> <span class="n">starItemContentLightedImage</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="sdiffusemenu">4、添加 SDiffuseMenu</h4>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">menuRect</span>  <span class="o">=</span> <span class="kt">CGRect</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                           <span class="nv">y</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                           <span class="nv">width</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                           <span class="nv">height</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
<span class="n">menu</span>          <span class="o">=</span>  <span class="kt">SDiffuseMenu</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="n">menuRect</span><span class="p">,</span>
                          <span class="nv">startItem</span><span class="p">:</span> <span class="n">startItem</span><span class="p">,</span>
                         <span class="nv">menusArray</span><span class="p">:</span> <span class="n">menus</span> <span class="k">as</span> <span class="kt">NSArray</span><span class="p">,</span>
                          <span class="nv">grapyType</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="o">.</span><span class="kt">SDiffuseMenuGrapyType</span><span class="o">.</span><span class="n">arc</span><span class="p">)</span>
<span class="n">menu</span><span class="o">.</span><span class="n">center</span>   <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="n">center</span>
<span class="n">menu</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
<span class="k">self</span><span class="o">.</span><span class="n">menuView</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="n">menu</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="section-4">5、动画配置</h4>

<ul>
  <li>如果配置弧线形动画,则动画中弧线半径变化为:0–&gt; 最大 farRadius–&gt; 最小 nearRadius–&gt; 结束 endRadius</li>
  <li>如果配置直线形动画,则动画中半径就是直线段的长度,变化为:0–&gt; 最大 farRadius–&gt; 最小 nearRadius–&gt;结束 endRadius</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 动画时长</span>
<span class="n">menu</span><span class="o">.</span><span class="n">animationDuration</span>  <span class="o">=</span> <span class="kt">CFTimeInterval</span><span class="p">(</span><span class="n">animationDrationValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span><span class="p">)</span>
<span class="c1">// 最小半径</span>
<span class="n">menu</span><span class="o">.</span><span class="n">nearRadius</span>         <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">nearRadiusValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 结束半径</span>
<span class="n">menu</span><span class="o">.</span><span class="n">endRadius</span>          <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">endRadiusValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 最大半径</span>
<span class="n">menu</span><span class="o">.</span><span class="n">farRadius</span>          <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">farRadiusValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 单个动画间隔时间</span>
<span class="n">menu</span><span class="o">.</span><span class="n">timeOffset</span>         <span class="o">=</span> <span class="kt">CFTimeInterval</span><span class="p">(</span><span class="n">timeOffSetValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span><span class="p">)</span><span class="o">!</span>
<span class="c1">// 整体角度</span>
<span class="n">menu</span><span class="o">.</span><span class="n">menuWholeAngle</span>     <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">menuWholeAngleValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 整体偏移角度</span>
<span class="n">menu</span><span class="o">.</span><span class="n">rotateAngle</span>        <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">rotateAngleValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 展开时自旋角度</span>
<span class="n">menu</span><span class="o">.</span><span class="n">expandRotation</span>     <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="kt">M_PI</span><span class="p">)</span>
<span class="c1">// 结束时自旋角度</span>
<span class="n">menu</span><span class="o">.</span><span class="n">closeRotation</span>      <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="kt">M_PI</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 是否旋转菜单按钮</span>
<span class="n">menu</span><span class="o">.</span><span class="n">rotateAddButton</span>    <span class="o">=</span> <span class="n">rotateAddButton</span><span class="o">.</span><span class="n">isOn</span>
<span class="c1">// 菜单按钮旋转角度</span>
<span class="n">menu</span><span class="o">.</span><span class="n">rotateAddButtonAngle</span> <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">rotateAddButtonAngleValue</span><span class="o">.</span><span class="n">text</span><span class="o">!</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">floatValue</span><span class="p">)</span>
<span class="c1">// 菜单展示的形状:直线 or 弧形</span>
<span class="n">menu</span><span class="o">.</span><span class="n">sDiffuseMenuGrapyType</span> <span class="o">=</span> <span class="n">isLineGrapyType</span><span class="o">.</span><span class="n">isOn</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">?</span> <span class="o">.</span><span class="nv">line</span> <span class="p">:</span> <span class="o">.</span><span class="n">arc</span>

<span class="c1">// 为方便使用,V1.1.0版本已枚举常见方位,可直接使用,无需再次设置 rotateAngle &amp;&amp; menuWholeAngle</span>
<span class="c1">// 若对于 rotateAngle\menuWholeAngle 不熟悉,建议查看 source 目录下的配置图片</span>
<span class="n">menu</span><span class="o">.</span><span class="n">sDiffuseMenuDirection</span> <span class="o">=</span> <span class="o">.</span><span class="n">above</span> <span class="c1">// 上方180°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .left // 左方180°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .below // 下方180°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .right // 右方180°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .upperRight // 右上方90°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .lowerRight // 右下方90°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .upperLeft // 左上方90°</span>
<span class="c1">//        menu.sDiffuseMenuDirection = .lowerLeft // 左下方90°</span>
</code></pre>
</div>

<h4 id="section-5">6、动画过程监听</h4>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="kt">SDiffuseMenuDidSelectMenuItem</span><span class="p">(</span><span class="n">_</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="p">,</span> <span class="n">didSelectIndex</span> <span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"选中按钮 at index:</span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s"> is: </span><span class="se">\(</span><span class="n">menu</span><span class="o">.</span><span class="nf">menuItemAtIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="se">)</span><span class="s"> "</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="kt">SDiffuseMenuDidClose</span><span class="p">(</span><span class="n">_</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"菜单关闭动画结束"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="kt">SDiffuseMenuDidOpen</span><span class="p">(</span><span class="n">_</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"菜单展开动画结束"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="kt">SDiffuseMenuWillOpen</span><span class="p">(</span><span class="n">_</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"菜单将要展开"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="kt">SDiffuseMenuWillClose</span><span class="p">(</span><span class="n">_</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">SDiffuseMenu</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"菜单将要关闭"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="swift">二、Swift转写之旅</h2>

<p>总的来说,动画的原理还是比较简单的,主要涉及到的知识点是 CABasicAnimation、CAKeyframeAnimation 以及事件响应链相关知识,下边分两部分介绍</p>

<h3 id="capropertyanimation">1、CAPropertyAnimation动画</h3>

<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Animation_Types_Timing/Art/animations_info_2x.png" alt="" /></p>

<p>在 SDiffuseMenu 中动画用 CAPropertyAnimation 的子类 CABasicAnimation 和 CAKeyframeAnimation 来实现,关于这两个子类简述如下:</p>

<ul>
  <li>CABasicAnimation 其实可以看作是一种特殊的关键帧动画,只有头尾两个关键帧,可实现移动、旋转、缩放等基本动画;</li>
  <li>CAKeyframeAnimation 则可以支持任意多个关键帧,关键帧有两种方式来指定,使用path或values;</li>
  <li>
    <ul>
      <li>path 可以是 CGPathRef、CGMutablePathRef 或者贝塞尔曲线,注意的是:设置了 path 之后 values 就无效了;values 则相对灵活, 可以指定任意关键帧帧值;</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>keyTimes 可以为 values 中的关键帧设置一一对应对应的时间点,其取值范围为0到1.0,keyTimes 没有设置的时候,各个关键帧的时间是平分的;</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>..</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>更多的动画知识请戳此处 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">CoreAnimation_guide</a></p>
  <blockquote>

    <p>相关的指南、示例代码可以通过点击页面右上角搜索按钮进行搜索,官方文档大多点到为止,挺适合入门学习的,更深的还需要在实践中摸索总结</p>
  </blockquote>
</blockquote>

<h3 id="section-6">2、动画分析</h3>

<p>在 V1.1.0 版本中,已扩展动画的形状:新加入直线型,其原理及计算方法同弧线形,下文不做过多介绍,详情参见版本记录</p>

<p>不论多么复杂的动画,都是由简单的动画组成的,大家先看下 SDiffuseMenu 中单选项动画：</p>

<p><img src="https://raw.githubusercontent.com/mythkiven/DiffuseMenu_Swift/master/Source/singleItemAnimation.gif" alt="" /></p>

<p>仔细分析发现可以将整个动画可以拆分为三大部分:</p>

<ul>
  <li>菜单按钮的自旋转,通过 transform 属性即可实现;</li>
  <li>选项按钮的整体展开动画,实际是在定时器中依次添加单个选项按钮的动画组,控制 timeInterval 来实现动画的先后执行顺序;</li>
  <li>单个选项按钮的动画则拆分为3部分:展开动画、结束动画和点击动画,都是动画组,下边以结束动画为例,简单介绍其实现过程</li>
</ul>

<h4 id="section-7">2.1、单个选项关闭动画分析：</h4>

<p>单选项按钮关闭动画过程如下:</p>

<p><img src="https://ooo.0o0.ooo/2017/01/20/58817b4e6ba40.png" alt="" /></p>

<p><strong>1、自旋</strong></p>

<p>大家仔细看会发现展开动画和结束动画的自旋转是有差异的,因为关键帧设置的不同</p>

<p>展开动画中设置的关键帧如下,0.1对应展开角度0°,0.3对应 expandRotation 自旋角度,0.4对应0°,所以在0.3 -&gt; 0.4的时间会出现较快速的自旋</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">rotateAnimation</span><span class="o">.</span><span class="n">values</span>   <span class="o">=</span> <span class="p">[</span><span class="kt">CGFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
                           <span class="kt">CGFloat</span><span class="p">(</span><span class="n">expandRotation</span><span class="p">),</span>
                           <span class="kt">CGFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)]</span>

<span class="n">rotateAnimation</span><span class="o">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="p">[</span><span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.1</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">),</span>
                           <span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.3</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">),</span>
                           <span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.4</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">)]</span>
</code></pre>
</div>

<p>而关闭的动画中,设置为0 -&gt; 0.4 慢速自旋,0.4 -&gt; 0.5 快速自旋</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">rotateAnimation</span><span class="o">.</span><span class="n">values</span>   <span class="o">=</span> <span class="p">[</span><span class="kt">CGFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
                           <span class="kt">CGFloat</span><span class="p">(</span><span class="n">closeRotation</span><span class="p">),</span>
                           <span class="kt">CGFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)]</span>

<span class="n">rotateAnimation</span><span class="o">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="p">[</span><span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">),</span>
                           <span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.4</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">),</span>
                           <span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">0.5</span> <span class="k">as</span> <span class="kt">Float</span><span class="p">)]</span>
</code></pre>
</div>

<p><strong>2、移动</strong></p>

<p>移动的控制在于 path 是怎样设定的,代码中我写了两种方法,其中一种被注释掉</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">positionAnimation</span>      <span class="o">=</span>  <span class="kt">CAKeyframeAnimation</span><span class="p">(</span><span class="nv">keyPath</span><span class="p">:</span> <span class="s">"position"</span><span class="p">)</span>
<span class="n">positionAnimation</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">animationDuration</span>
</code></pre>
</div>

<p>1)\使用贝塞尔曲线作为 path,从代码中可以明显的看出移动的路径: endPoint -&gt; farPoint -&gt; startPoint</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="kt">UIBezierPath</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
<span class="n">path</span><span class="o">.</span><span class="nf">move</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">endPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">endPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">path</span><span class="o">.</span><span class="nf">addLine</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">farPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">farPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">path</span><span class="o">.</span><span class="nf">addLine</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">startPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">startPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">positionAnimation</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">cgPath</span>
</code></pre>
</div>

<p>2)\使用 CGPathRef 或 GCMutablePathRef 设置路径</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">path</span> <span class="o">=</span>  <span class="kt">CGMutablePath</span><span class="p">()</span>
<span class="n">path</span><span class="o">.</span><span class="nf">move</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">endPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">endPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">path</span><span class="o">.</span><span class="nf">addLine</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">farPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">farPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">path</span><span class="o">.</span><span class="nf">addLine</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="kt">CGPoint</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">startPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">startPoint</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">positionAnimation</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
</code></pre>
</div>

<p>自旋和平移都有了,接下来要加入到动画组中：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">animationgroup</span>              <span class="o">=</span>  <span class="kt">CAAnimationGroup</span><span class="p">()</span>
<span class="n">animationgroup</span><span class="o">.</span><span class="n">animations</span>       <span class="o">=</span> <span class="p">[</span><span class="n">positionAnimation</span><span class="p">,</span> <span class="n">rotateAnimation</span><span class="p">]</span>
<span class="n">animationgroup</span><span class="o">.</span><span class="n">duration</span>         <span class="o">=</span> <span class="n">animationDuration</span>
<span class="c1">// 动画结束后,layer保持最终的状态</span>
<span class="n">animationgroup</span><span class="o">.</span><span class="n">fillMode</span>         <span class="o">=</span> <span class="n">kCAFillModeForwards</span>
<span class="c1">// 速度控制我设置的如此,大家根据需要自行修改即可</span>
<span class="n">animationgroup</span><span class="o">.</span><span class="n">timingFunction</span>   <span class="o">=</span> <span class="kt">CAMediaTimingFunction</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionEaseIn</span><span class="p">)</span>
<span class="c1">// 代理是为了获取到动画结束的信号</span>
<span class="n">animationgroup</span><span class="o">.</span><span class="n">delegate</span>         <span class="o">=</span> <span class="k">self</span>
</code></pre>
</div>

<p>最添加进 layer 即可</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">item</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="n">animationgroup</span><span class="p">,</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"Close"</span><span class="p">)</span>
</code></pre>
</div>
<p>其余的动画原理和上述的关闭动画其实是一样的,基于属性的动画,通过操作帧来实现我们想要的效果,小伙伴们直接看代码吧~</p>

<h4 id="section-8">2.2、整体动画的控制</h4>

<p>注意,整体动画的控制以上并未表述,在这个地方也需要注意下,为了让整体动画在一个合适的角度展示出来,就需要从整体上控制角度</p>

<p><img src="https://ooo.0o0.ooo/2017/01/16/587c8c512c911.png" alt="" />
<img src="https://ooo.0o0.ooo/2017/01/16/587c8c7530072.png" alt="" />
<img src="https://ooo.0o0.ooo/2017/01/16/587c8c8635998.png" alt="" /></p>

<p>从上图中可以看出,整体的角度是由 menuWholeAngle 和 rotateAngle 共同控制的</p>

<ul>
  <li>menuWholeAngle: 控制整体动画的范围角度;</li>
  <li>rotateAngle: 用于控制整体的偏移角度</li>
</ul>


                </div>
                <div class="read-all">
                    <a  href="/2017/01/18/SDiffuseMenu/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/11/swift_X_Initialization_Deinitialization/">Swift3.0_X_构造过程和析构过程 </a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-11
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">构造过程</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">存储属性的初始赋值</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">自定义构造过程</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">默认构造器</a></li>
    </ul>
  </li>
</ul>

<h1 id="section">构造过程</h1>

<ul>
  <li>构造过程是使用类、结构体或枚举类型的实例之前的准备过程；</li>
  <li>通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法；</li>
  <li>与OC中的构造器不同，Swift的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化；</li>
  <li>类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作</li>
</ul>

<h3 id="section-1">存储属性的初始赋值</h3>

<ul>
  <li>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值；</li>
  <li>可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值；</li>
  <li>当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者</li>
</ul>

<p>1、构造器</p>

<p>以关键字init命名：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 在此处执行构造过程</span>
<span class="p">}</span>
</code></pre>
</div>

<p>案例：</p>

<p>这个结构体定义了一个不带参数的构造器init，并在里面将存储型属性temperature的值初始化为32.0</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 保存华氏温度的结构体Fahrenheit</span>
<span class="kd">struct</span> <span class="kt">Fahrenheit</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperature</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">f</span> <span class="o">=</span> <span class="kt">Fahrenheit</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The default temperature is </span><span class="se">\(</span><span class="n">f</span><span class="o">.</span><span class="n">temperature</span><span class="se">)</span><span class="s">° Fahrenheit"</span><span class="p">)</span>
<span class="c1">// 打印 "The default temperature is 32.0° Fahrenheit”</span>
</code></pre>
</div>

<p>2、默认属性值</p>

<p>如前所述，可以在构造器中为存储型属性设置初始值。同样，也可以在属性声明时为其设置默认值</p>

<p>注意：如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能充分利用默认构造器、构造器继承等特性，后续章节将讲到。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：</span>
<span class="kd">struct</span> <span class="kt">Fahrenheit</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-2">自定义构造过程</h3>

<p>可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。</p>

<p>1、构造参数：</p>

<p>自定义构造过程时，可以在定义中提供构造参数，指定所需值的类型和名字。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：</span>

<span class="kd">struct</span> <span class="kt">Celsius</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperatureInCelsius</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="c1">// 构造参数，其外部名字为fromFahrenheit,内部名字为fahrenheit</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nv">fahrenheit</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
    <span class="p">}</span>
    <span class="c1">// 构造参数，其外部名字为fromKelvin，内部名字为kelvin</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nv">kelvin</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">boilingPointOfWater</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="nv">fromFahrenheit</span><span class="p">:</span> <span class="mf">212.0</span><span class="p">)</span>
<span class="c1">// boilingPointOfWater.temperatureInCelsius 是 100.0</span>
<span class="k">let</span> <span class="nv">freezingPointOfWater</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="nv">fromKelvin</span><span class="p">:</span> <span class="mf">273.15</span><span class="p">)</span>
<span class="c1">// freezingPointOfWater.temperatureInCelsius 是 0.0</span>
</code></pre>
</div>

<p>2、参数的内部名称和外部名称：</p>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>当中有多个构造器时，需要通过外部名称来识别不同的构造器：在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>

<p>以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。</span>

<span class="kd">struct</span> <span class="kt">Color</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">red</span>   <span class="o">=</span> <span class="n">red</span>
        <span class="k">self</span><span class="o">.</span><span class="n">green</span> <span class="o">=</span> <span class="n">green</span>
        <span class="k">self</span><span class="o">.</span><span class="n">blue</span>  <span class="o">=</span> <span class="n">blue</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">white</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">red</span>   <span class="o">=</span> <span class="n">white</span>
        <span class="n">green</span> <span class="o">=</span> <span class="n">white</span>
        <span class="n">blue</span>  <span class="o">=</span> <span class="n">white</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>两种构造器都能用于创建一个新的Color实例，你需要为构造器每个外部参数传值：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">magenta</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">halfGray</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="nv">white</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">)</span>
</code></pre>
</div>
<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">veryGreen</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="c1">// 报编译时错误，需要外部名称</span>
</code></pre>
</div>

<p>3、不带外部名的构造器参数：</p>

<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">下面是之前Celsius例子的扩展</span><span class="err">，</span><span class="n">跟之前相比添加了一个带有Double类型参数的构造器</span><span class="err">，</span><span class="n">其外部名用_代替</span><span class="err">：</span>

<span class="kd">struct</span> <span class="kt">Celsius</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperatureInCelsius</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nv">fahrenheit</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nv">kelvin</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">celsius</span><span class="p">:</span> <span class="kt">Double</span><span class="p">){</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">celsius</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">bodyTemperature</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
<span class="c1">// bodyTemperature.temperatureInCelsius 为 37.0</span>
<span class="c1">// 调用Celsius(37.0)意图明确，不需要外部参数名称。</span>
</code></pre>
</div>

<p>4、可选属性类型</p>

<p>如果定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。</p>

<p>下面例子中定义了类SurveyQuestion，它包含一个可选字符串属性response：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SurveyQuestion</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">ask</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">cheeseQuestion</span> <span class="o">=</span> <span class="kt">SurveyQuestion</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="s">"Do you like cheese?"</span><span class="p">)</span>
<span class="n">cheeseQuestion</span><span class="o">.</span><span class="nf">ask</span><span class="p">()</span>
<span class="c1">// 打印 "Do you like cheese?"</span>
<span class="n">cheeseQuestion</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">"Yes, I do like cheese."</span>

<span class="c1">// 调查问题的答案在回答前是无法确定的，因此我们将属性response声明为String?类型，或者说是可选字符串类型。当SurveyQuestion实例化时，它将自动赋值为nil，表明此字符串暂时还没有值。</span>
</code></pre>
</div>

<p>5、构造过程中常量属性的修改</p>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>

<p>注意：对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>

<h3 id="section-3">默认构造器</h3>

<p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>

<p>案例:下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ShoppingListItem</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">quantity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">var</span> <span class="nv">purchased</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">item</span> <span class="o">=</span> <span class="kt">ShoppingListItem</span><span class="p">()</span>
</code></pre>
</div>
<p>由于ShoppingListItem类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为name属性设置默认值，但由于name是可选字符串类型，它将默认设置为nil）。上面例子中使用默认构造器创造了一个ShoppingListItem类的实例（使用ShoppingListItem()形式的构造器语法），并将其赋值给变量item。</p>

<p>2、结构体的逐一成员构造器</p>

<p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>

<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 结构体Size自动获得了一个逐一成员构造器init(width:height:)。你可以用它来为Size创建新的实例：</span>

<span class="kd">struct</span> <span class="kt">Size</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">twoByTwo</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
</code></pre>
</div>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/11/swift_X_Initialization_Deinitialization/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/">Swift3.0_IX_方法、下标和继承 </a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-10
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#methods" id="markdown-toc-methods">方法 Methods</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">类型方法</a></li>
    </ul>
  </li>
  <li><a href="#subscripts" id="markdown-toc-subscripts">下标 Subscripts</a></li>
  <li><a href="#inheritance" id="markdown-toc-inheritance">继承 Inheritance</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">定义基类</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">子类生成</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">重写</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">防止重写</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="methods">方法 Methods</h1>

<p>方法是与某些特定类型相关联的函数。</p>

<ul>
  <li>类、结构体、枚举都可以定义实例方法；</li>
  <li>
    <p>实例方法为给定类型的实例封装了具体的任务与功能；</p>
  </li>
  <li>类、结构体、枚举也可以定义类型方法；</li>
  <li>
    <p>类型方法与类型本身相关联，与 OC中的类方法类似；</p>
  </li>
  <li>结构体和枚举能够定义方法是 Swift 与 C/OC的主要区别之一；</li>
  <li>在OC中，类是唯一能定义方法的类型；；</li>
  <li>但在Swift中，不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在创建的类型（类/结构体/枚举）上定义方法。</li>
</ul>

<p>1、实例方法</p>

<ul>
  <li>实例方法是属于某个特定类、结构体或者枚举类型实例的方法；</li>
  <li>实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致</li>
  <li>实例方法要写在它所属的类型的前后大括号之间</li>
  <li>实例方法能够隐式访问它所属类型的所有的其他实例方法和属性</li>
  <li>实例方法只能被它所属的类的某个特定实例调用</li>
  <li>实例方法不能脱离于现存的实例而被调用
案例：</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Counter类，它可用于计算次数的动作时发生的数量：</span>

<span class="kd">class</span> <span class="kt">Counter</span> <span class="p">{</span>
    <span class="c1">// 本Counter类还声明一个变量属性count，以跟踪当前计数器值。</span>
    <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 实例方法:increment()递增计数器1</span>
    <span class="kd">func</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// 实例方法:increment(by: Int) 将计数器增加指定的整数值</span>
    <span class="kd">func</span> <span class="nf">increment</span><span class="p">(</span><span class="n">by</span> <span class="nv">amount</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">amount</span>
    <span class="p">}</span>
    <span class="c1">// reset() 将计数器重置为零</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">counter</span> <span class="o">=</span> <span class="kt">Counter</span><span class="p">()</span>
<span class="c1">// the initial counter value is 0</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">increment</span><span class="p">()</span>
<span class="c1">// the counter's value is now 1</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">increment</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// the counter's value is now 6</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">reset</span><span class="p">()</span>
<span class="c1">// the counter's value is now 0</span>
</code></pre>
</div>

<p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用）(通过参数标签，参数名称是实现)。方法参数也一样，因为方法就是函数，只是这个函数与某个类型相关联了。</p>

<p>2、 self属性</p>

<ul>
  <li>类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身；</li>
  <li>你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例；</li>
  <li>一般不用在类型实例里面写self,Swift默认指当前实例的属性或者方法；</li>
  <li>一般使用self用于严谨的区分参数和属性。
```swift
// 上面例子中的increment方法还可以这样写：
func increment() {
  self.count += 1
}</li>
</ul>

<p>// 区分参数和属性
struct Point {
    // x,y是属性
    var x = 0.0, y = 0.0
    // x是参数
    func isToTheRightOfX(x: Double) -&gt; Bool {
        // 要进行区分:否则Swift会认为X都是参数。
        return self.x &gt; x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOfX(1.0) {
    print(“This point is to the right of the line where x == 1.0”)
}
// 打印 “This point is to the right of the line where x == 1.0”</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
3、在实例方法中修改值类型

- 结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改；
- 但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；
- 并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中；
- 方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例；
- 要使用可变方法，将关键字mutating 放到方法的func关键字之前就可以了：

```swift
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// Prints "The point is now at (3.0, 4.0)"
</code></pre>
</div>

<p>注意：不能在结构体类型的常量类型上调用可变方法，因为其属性不能被改变，即使属性是变量属性。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">fixedPoint</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="n">fixedPoint</span><span class="o">.</span><span class="nf">moveByX</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="c1">// 这里将会报告一个错误</span>
</code></pre>
</div>

<p>4、在可变方法中给self赋值</p>

<p>可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Point</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">moveBy</span><span class="p">(</span><span class="n">x</span> <span class="nv">deltaX</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="n">y</span> <span class="nv">deltaY</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">deltaX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">deltaY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 新版的可变方法moveBy(x:y:)创建了一个新的结构体实例，它的 x 和 y 的值都被设定为目标值。调用这个版本的方法和调用上个版本的最终结果是一样的。</span>
</code></pre>
</div>

<p>枚举的可变方法可以把self设置为同一枚举类型中不同的成员：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">TriStateSwitch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Off</span><span class="p">,</span> <span class="kt">Low</span><span class="p">,</span> <span class="kt">High</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">Off</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Low</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">Low</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">High</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">High</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Off</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">ovenLight</span> <span class="o">=</span> <span class="kt">TriStateSwitch</span><span class="o">.</span><span class="kt">Low</span>
<span class="n">ovenLight</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// ovenLight 现在等于 .High</span>
<span class="n">ovenLight</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// ovenLight 现在等于 .Off</span>
</code></pre>
</div>
<p>上面的例子中定义了一个三态开关的枚举。每次调用next()方法时，开关在不同的电源状态（Off，Low，High）之间循环切换。</p>

<h3 id="section">类型方法</h3>

<ul>
  <li>实例方法是被某个类型的实例调用的方法；</li>
  <li>也可以定义在类型本身上调用的方法，这种方法就叫做类型方法；</li>
  <li>在方法的func关键字之前加上关键字static，来指定类型方法；</li>
  <li>类还可以用关键字class来允许子类重写父类的方法实现；</li>
  <li>类型方法和实例方法一样用点语法调用；</li>
</ul>

<p>注意：
在OC中，只能为OC的类类型（classes）定义类型方法。在Swift中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="kd">func</span> <span class="nf">someTypeMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 在这里实现类型方法</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">SomeClass</span><span class="o">.</span><span class="nf">someTypeMethod</span><span class="p">()</span>
</code></pre>
</div>

<ul>
  <li>在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例；</li>
  <li>这意味着可以用self来消除类型属性和类型方法参数之间的歧义；</li>
  <li>一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称；</li>
  <li>类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称；</li>
</ul>

<p>案例：
下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</span>

<span class="kd">struct</span> <span class="kt">LevelTracker</span> <span class="p">{</span>
    <span class="c1">// 类型属性：highestUnlockedLevel监测玩家已解锁的最高等级</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">highestUnlockedLevel</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">// 实例属性:currentLevel来监测每个玩家当前的等级</span>
    <span class="k">var</span> <span class="nv">currentLevel</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">// 类型方法：一旦新等级被解锁，它会更新highestUnlockedLevel的值</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">_</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">highestUnlockedLevel</span> <span class="p">{</span> <span class="n">highestUnlockedLevel</span> <span class="o">=</span> <span class="n">level</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 如果某个给定的等级已经被解锁，它将返回true</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">isUnlocked</span><span class="p">(</span><span class="n">_</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// 尽管没有使用类似LevelTracker.highestUnlockedLevel的写法，这个类型方法还是能够访问类型属性highestUnlockedLevel</span>
        <span class="k">return</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">highestUnlockedLevel</span>
    <span class="p">}</span>
    
    <span class="c1">// 实例方法，管理currentLevel属性</span>
    <span class="c1">// 这个方法会在更新currentLevel之前检查所请求的新等级是否已经解锁</span>
    <span class="kd">@discardableResult</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">advance</span><span class="p">(</span><span class="n">to</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="kt">LevelTracker</span><span class="o">.</span><span class="nf">isUnlocked</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">currentLevel</span> <span class="o">=</span> <span class="n">level</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 在调用advance(to:)时候忽略返回值，不会产生编译警告，所以函数被标注为@ discardableResult属性</span>
    <span class="c1">//@discardableResult 将此属性应用于函数或方法声明以在不使用其结果的情况下调用返回值的函数或方法时抑制编译器警告。</span>
<span class="p">}</span>
</code></pre>
</div>

<p>下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Player</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">tracker</span> <span class="o">=</span> <span class="kt">LevelTracker</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">playerName</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="nf">complete</span><span class="p">(</span><span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">LevelTracker</span><span class="o">.</span><span class="nf">unlock</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tracker</span><span class="o">.</span><span class="nf">advance</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">playerName</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。</p>

<p>还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">player</span> <span class="o">=</span> <span class="kt">Player</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Argyrios"</span><span class="p">)</span>
<span class="n">player</span><span class="o">.</span><span class="nf">complete</span><span class="p">(</span><span class="nv">level</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"highest unlocked level is now </span><span class="se">\(</span><span class="kt">LevelTracker</span><span class="o">.</span><span class="n">highestUnlockedLevel</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "highest unlocked level is now 2"</span>
</code></pre>
</div>

<h1 id="subscripts">下标 Subscripts</h1>

<ul>
  <li>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式；</li>
  <li>可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法；</li>
  <li>举例：用下标访问一个Array实例中的元素可以写作someArray[index]；</li>
  <li>举例：访问Dictionary实例中的元素可以写作someDictionary[key]；</li>
  <li>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</li>
</ul>

<p>1、下标语法</p>

<p>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标使用subscript关键字，指定一个或多个输入参数和返回类型；与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="c1">// 返回一个适当的 Int 类型的值</span>
    <span class="p">}</span>

    <span class="nf">set</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 执行适当的赋值操作</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数</span>
</code></pre>
</div>

<p>只读下标：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 如同只读计算型属性，可以省略只读下标的get关键字：</span>
<span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="c1">// 返回一个适当的 Int 类型的值</span>
<span class="p">}</span>
</code></pre>
</div>

<p>只读下标的实现：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 这里定义了一个TimesTable结构体，用来表示传入整数的乘法表：</span>
<span class="kd">struct</span> <span class="kt">TimesTable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">multiplier</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">multiplier</span> <span class="o">*</span> <span class="n">index</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">threeTimesTable</span> <span class="o">=</span> <span class="kt">TimesTable</span><span class="p">(</span><span class="nv">multiplier</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"six times three is </span><span class="se">\(</span><span class="n">threeTimesTable</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "six times three is 18"</span>

<span class="c1">// 在上例中，创建了一个TimesTable实例，用来表示整数3的乘法表。数值3被传递给结构体的构造函数，作为实例成员multiplier的值。</span>
</code></pre>
</div>

<p>2、下标用法</p>

<p>下标的确切含义取决于使用场景。下标通常作为访问集合，列表或序列中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标。</p>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Swift 的Dictionary类型实现下标用于对其实例中储存的值进行存取操作。为字典设值时，在下标中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标：</span>

<span class="k">var</span> <span class="nv">numberOfLegs</span> <span class="o">=</span> <span class="p">[</span><span class="s">"spider"</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">"ant"</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s">"cat"</span><span class="p">:</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">numberOfLegs</span><span class="p">[</span><span class="s">"bird"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre>
</div>
<p>注意:Swift 的Dictionary类型的下标接受并返回可选类型的值。上例中的numberOfLegs字典通过下标返回的是一个Int?或者说“可选的int”。Dictionary类型之所以如此实现下标，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。</p>

<p>3、下标选项</p>

<p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>

<p>下标的重载：一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是下标的重载。</p>

<p>虽然接受单一入参的下标是最常见的，但也可以根据情况定义接受多个入参的下标。例如下例定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵。Matrix结构体的下标接受两个整型参数：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Matrix</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rows</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">grid</span><span class="p">:</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">rows</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="k">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">columns</span><span class="p">,</span> <span class="nv">repeatedValue</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">columns</span>
    <span class="p">}</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="nf">assert</span><span class="p">(</span><span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="n">column</span><span class="p">),</span> <span class="s">"Index out of range"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="nf">assert</span><span class="p">(</span><span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="n">column</span><span class="p">),</span> <span class="s">"Index out of range"</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Matrix提供了一个接受两个入参的构造方法，入参分别是rows和columns，创建了一个足够容纳rows * columns个Double类型的值的数组。通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0</p>

<p>你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">matrix</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">(</span><span class="nv">rows</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>
<p>上例中创建了一个Matrix实例来表示两行两列的矩阵。该Matrix实例的grid数组按照从左上到右下的阅读顺序将矩阵扁平化存储：
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png" alt="" /></p>

<p>将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.2</span>
</code></pre>
</div>
<p>上面两条语句分别调用下标的 setter 将矩阵右上角位置（即row为0、column为1的位置）的值设置为1.5，将矩阵左下角位置（即row为1、column为0的位置）的值设置为3.2：</p>

<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png" alt="" /></p>

<p>Matrix下标的 getter 和 setter 中都含有断言，用来检查下标入参row和column的值是否有效。为了方便进行断言，Matrix包含了一个名为indexIsValidForRow(_:column:)的便利方法，用来检查入参row和column的值是否在矩阵范围内：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">columns</span>
<span class="p">}</span>
</code></pre>
</div>
<p>断言在下标越界时触发：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someValue</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="c1">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span>
</code></pre>
</div>

<h1 id="inheritance">继承 Inheritance</h1>

<p>一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>

<p>在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>

<p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>

<h3 id="section-1">定义基类</h3>

<p>不继承于其它类的类，称之为基类。</p>

<p>注意：Swift中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Vehicle基类也定义了一个名为makeNoise的方法。这个方法实际上不为Vehicle实例做任何事，但之后将会被Vehicle的子类定制：</span>

<span class="kd">class</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentSpeed</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"traveling at </span><span class="se">\(</span><span class="n">currentSpeed</span><span class="se">)</span><span class="s"> miles per hour"</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">makeNoise</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 什么也不做-因为车辆不一定会有噪音</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>可以用初始化语法创建一个Vehicle的新实例，即类名后面跟一个空括号</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someVehicle</span> <span class="o">=</span> <span class="kt">Vehicle</span><span class="p">()</span>
</code></pre>
</div>

<h2 id="section-2">子类生成</h2>

<p>子类生成指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span><span class="p">:</span> <span class="kt">SomeSuperclass</span> <span class="p">{</span>
    <span class="c1">// 这里是子类的定义</span>
<span class="p">}</span>
</code></pre>
</div>
<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Bicycle</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">hasBasket</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">bicycle</span> <span class="o">=</span> <span class="kt">Bicycle</span><span class="p">()</span>
<span class="n">bicycle</span><span class="o">.</span><span class="n">hasBasket</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// 可以修改Bicycle实例所继承的currentSpeed属性，和查询实例所继承的description属性：</span>
<span class="n">bicycle</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">15.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Bicycle: </span><span class="se">\(</span><span class="n">bicycle</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "Bicycle: traveling at 15.0 miles per hour"</span>

<span class="c1">// 子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：</span>
<span class="kd">class</span> <span class="kt">Tandem</span><span class="p">:</span> <span class="kt">Bicycle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentNumberOfPassengers</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">tandem</span> <span class="o">=</span> <span class="kt">Tandem</span><span class="p">()</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">hasBasket</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">currentNumberOfPassengers</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">22.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Tandem: </span><span class="se">\(</span><span class="n">tandem</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印："Tandem: traveling at 22.0 miles per hour"</span>
</code></pre>
</div>

<h3 id="section-3">重写</h3>

<p>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。这种行为叫重写。</p>

<p>如果要重写某个特性，需要在重写定义的前面加上override关键字。这么做，就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少override关键字的重写都会在编译时被诊断为错误。</p>

<p>override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>

<p>1、 访问超类的方法，属性及下标</p>

<p>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>

<p>在合适的地方，你可以通过使用super前缀来访问超类版本的方法，属性或下标：</p>
<ul>
  <li>在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。</li>
  <li>在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。</li>
  <li>在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。</li>
</ul>

<p>2、重写方法</p>

<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法</span>
<span class="kd">class</span> <span class="kt">Train</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">makeNoise</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Choo Choo"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>3、重写属性</p>

<p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>

<ul>
  <li>可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可；</li>
  <li>但是，不可以将一个继承来的读写属性重写为一个只读属性；</li>
  <li>提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性；</li>
  <li>子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型；</li>
  <li>在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的；</li>
</ul>

<p>注意
如果在重写属性中提供了setter，那么也一定要提供getter。如果不想在重写版本中的getter里修改继承来的属性值，可以直接通过super.someProperty来返回继承来的值，其中someProperty是要重写的属性的名字。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Car</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">gear</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">super</span><span class="o">.</span><span class="n">description</span> <span class="o">+</span> <span class="s">" in gear </span><span class="se">\(</span><span class="n">gear</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 重写的description属性首先要调用super.description返回Vehicle类的description属性。之后，Car类版本的description在末尾增加了一些额外的文本来提供关于当前档位的信息。</span>
</code></pre>
</div>

<p>4、重写属性观察器</p>

<p>可以通过重写属性为一个继承来的属性添加属性观察器。当继承来的属性值发生改变时，就会被通知到，无论那个属性原本是如何实现的。</p>

<p>注意：不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。
此外还要注意，不可以同时提供重写的 setter 和重写的属性观察器。如果想观察属性值的变化，并且已经为那个属性提供了定制的 setter，那么在 setter 中就可以观察到任何值变化了。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</span>
<span class="kd">class</span> <span class="kt">AutomaticCar</span><span class="p">:</span> <span class="kt">Car</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">var</span> <span class="nv">currentSpeed</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">gear</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">currentSpeed</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
当你设置AutomaticCar的currentSpeed属性，属性的didSet观察器就会自动地设置gear属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位gear的值。例如，速度为35.0时，挡位为4：
*/</span>

<span class="k">let</span> <span class="nv">automatic</span> <span class="o">=</span> <span class="kt">AutomaticCar</span><span class="p">()</span>
<span class="n">automatic</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">35.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"AutomaticCar: </span><span class="se">\(</span><span class="n">automatic</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "AutomaticCar: traveling at 35.0 miles per hour in gear 4"</span>
</code></pre>
</div>

<h3 id="section-4">防止重写</h3>

<p>可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。</p>

<p>如果重写了带有final标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final 的。</p>

<p>可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/">Swift3.0_VIII_枚举、类、结构体、属性</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-08
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">枚举</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">枚举语法：</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">原始值</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">递归枚举</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">类和结构体</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">类和结构体的对比</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">结构和枚举是值类型</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">类是引用类型</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">恒等运算符</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">指针</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">选择类还是结构体</a></li>
      <li><a href="#section-11" id="markdown-toc-section-11">字符串、数组、和字典类型的赋值与复制</a></li>
    </ul>
  </li>
  <li><a href="#properties" id="markdown-toc-properties">属性：Properties</a>    <ul>
      <li><a href="#stored-properties" id="markdown-toc-stored-properties">储存属性 Stored Properties</a></li>
      <li><a href="#computed-properties" id="markdown-toc-computed-properties">计算属性 Computed Properties</a></li>
      <li><a href="#property-observers" id="markdown-toc-property-observers">属性观察器 Property Observers</a></li>
      <li><a href="#global-and-local-variables" id="markdown-toc-global-and-local-variables">全局变量和局部变量 Global and Local Variables</a></li>
      <li><a href="#type-properties" id="markdown-toc-type-properties">类型属性 Type Properties</a></li>
    </ul>
  </li>
</ul>

<p>枚举为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>

<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>

<h1 id="section">枚举</h1>

<h3 id="section-1">枚举语法：</h3>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">SomeEnumeration</span> <span class="p">{</span>
    <span class="c1">// enumeration definition goes here</span>
<span class="p">}</span>
</code></pre>
</div>

<p>指南针案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">CompassPoint</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">north</span>
    <span class="k">case</span> <span class="n">south</span>
    <span class="k">case</span> <span class="n">east</span>
    <span class="k">case</span> <span class="n">west</span>
<span class="p">}</span>
</code></pre>
</div>

<p>注意
与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。</p>

<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Planet</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercury</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">earth</span><span class="p">,</span> <span class="n">mars</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturn</span><span class="p">,</span> <span class="n">uranus</span><span class="p">,</span> <span class="n">neptune</span>
<span class="p">}</span>
</code></pre>
</div>

<p>可以这样使用：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">directionToHead</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span>
</code></pre>
</div>

<p>当directionToHead的类型已知时，再次为其赋值可以使用更简短的点语法：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">directionToHead</span> <span class="o">=</span> <span class="o">.</span><span class="n">east</span>
</code></pre>
</div>

<p>使用 Switch 语句匹配枚举值</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">directionToHead</span> <span class="o">=</span> <span class="o">.</span><span class="n">south</span>
<span class="k">switch</span> <span class="n">directionToHead</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">north</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Lots of planets have a north"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">south</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Watch out for penguins"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">east</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Where the sun rises"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">west</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Where the skies are blue"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "Watch out for penguins"</span>
</code></pre>
</div>

<p>当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">somePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="o">.</span><span class="n">earth</span>
<span class="k">switch</span> <span class="n">somePlanet</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">earth</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Mostly harmless"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 打印 "Mostly harmless”</span>
</code></pre>
</div>

<p>在 Swift 中，使用如下方式定义表示两种商品条形码(条形码、QR码)的枚举：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Barcode</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">upc</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">qrCode</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// “定义一个名为Barcode的枚举类型，它的一个成员值是具有(Int，Int，Int，Int)类型关联值的upc，另一个成员值是具有String类型关联值的qrCode。”</span>
</code></pre>
</div>

<p>然后可以使用任意一种条形码类型创建新的条形码，例如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">productBarcode</span> <span class="o">=</span> <span class="kt">Barcode</span><span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// 创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)。</span>

<span class="c1">// 同一个商品可以被分配一个不同类型的条形码，例如：</span>
<span class="n">productBarcode</span> <span class="o">=</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="s">"ABCDEFGHIJKLMNOP"</span><span class="p">)</span>

<span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="k">let</span> <span class="nv">numberSystem</span><span class="p">,</span> <span class="k">let</span> <span class="nv">manufacturer</span><span class="p">,</span> <span class="k">let</span> <span class="nv">product</span><span class="p">,</span> <span class="k">let</span> <span class="nv">check</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"UPC: </span><span class="se">\(</span><span class="n">numberSystem</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">manufacturer</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">product</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">check</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="k">let</span> <span class="nv">productCode</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"QR code: </span><span class="se">\(</span><span class="n">productCode</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "QR code: ABCDEFGHIJKLMNOP."</span>

<span class="c1">// 如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</span>
<span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="n">numberSystem</span><span class="p">,</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">check</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"UPC: </span><span class="se">\(</span><span class="n">numberSystem</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">manufacturer</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">product</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">check</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="n">productCode</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"QR code: </span><span class="se">\(</span><span class="n">productCode</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span>
</code></pre>
</div>

<h3 id="section-2">原始值</h3>

<p>枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">ASCIIControlCharacter</span><span class="p">:</span> <span class="kt">Character</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tab</span> <span class="o">=</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span>
    <span class="k">case</span> <span class="n">lineFeed</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
    <span class="k">case</span> <span class="n">carriageReturn</span> <span class="o">=</span> <span class="s">"</span><span class="se">\r</span><span class="s">"</span>
<span class="p">}</span>
<span class="c1">// 枚举类型ASCIIControlCharacter的原始值类型被定义为Character，并设置了一些比较常见的 ASCII 控制字符</span>
</code></pre>
</div>

<p>原始值的隐式赋值</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Planet</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercury</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">earth</span><span class="p">,</span> <span class="n">mars</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturn</span><span class="p">,</span> <span class="n">uranus</span><span class="p">,</span> <span class="n">neptune</span>
<span class="p">}</span>
<span class="c1">//  venus == 2  earth ==3...</span>
</code></pre>
</div>

<p>使用枚举成员的rawValue属性可以访问该枚举成员的原始值：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">earthsOrder</span> <span class="o">=</span> <span class="kt">Planet</span><span class="o">.</span><span class="n">earth</span><span class="o">.</span><span class="n">rawValue</span>
<span class="c1">// earthsOrder is 3</span>
 
<span class="k">let</span> <span class="nv">sunsetDirection</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span><span class="o">.</span><span class="n">rawValue</span>
<span class="c1">// sunsetDirection is "west"</span>
</code></pre>
</div>

<p>使用原始值初始化枚举实例</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">possiblePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">// possiblePlanet is of type Planet? and equals Planet.uranus</span>
<span class="c1">// possiblePlanet是Planet?类型，或者说“可选的Planet”。</span>
</code></pre>
</div>

<p>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：</span>

<span class="k">let</span> <span class="nv">positionToFind</span> <span class="o">=</span> <span class="mi">11</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">somePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">positionToFind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">somePlanet</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">earth</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Mostly harmless"</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"There isn't a planet at position </span><span class="se">\(</span><span class="n">positionToFind</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "There isn't a planet at position 11"</span>
</code></pre>
</div>

<h3 id="section-3">递归枚举</h3>

<p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 在枚举成员前加上indirect来表示该成员可递归。</span>
<span class="kd">enum</span> <span class="kt">ArithmeticExpression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">number</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">addition</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">multiplication</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：</span>
<span class="kd">indirect</span> <span class="kd">enum</span> <span class="kt">ArithmeticExpression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">number</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">addition</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">multiplication</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 应用：</span>
<span class="k">let</span> <span class="nv">five</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">four</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">addition</span><span class="p">(</span><span class="n">five</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">product</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">multiplication</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="c1">// 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式</span>
<span class="kd">func</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">_</span> <span class="nv">expression</span><span class="p">:</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">expression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">addition</span><span class="p">(</span><span class="k">left</span><span class="p">,</span> <span class="k">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">multiplication</span><span class="p">(</span><span class="k">left</span><span class="p">,</span> <span class="k">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">left</span><span class="p">)</span> <span class="o">*</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">right</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">product</span><span class="p">))</span>
<span class="c1">// 打印 "18"</span>
</code></pre>
</div>

<h1 id="section-4">类和结构体</h1>

<p>与其他编程语言所不同的是，Swift 并不要求为自定义类和结构去创建独立的接口和实现文件。只需要在单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>

<h3 id="section-5">类和结构体的对比</h3>

<p>1、共同点：</p>

<ul>
  <li>定义要存储值的属性</li>
  <li>定义方法以提供功能</li>
  <li>定义下标，以使用下标语法访问其值</li>
  <li>定义初始化程序以设置其初始状态</li>
  <li>扩展其功能超出默认实现</li>
  <li>符合协议以提供某种类型的标准功能</li>
</ul>

<p>2、类独有功能：</p>

<ul>
  <li>继承使一个类能够继承另一个类的特性。</li>
  <li>类型转换使您能够在运行时检查和解释类实例的类型。</li>
  <li>Deinitializers使一个类的实例释放它分配的任何资源。</li>
  <li>引用计数允许对类实例的多个引用。</li>
</ul>

<p>注意：结构在code中传递并不会使用引用计数：Structures are always copied when they are passed around in your code, and do not use reference counting.</p>

<p>不同之处：</p>

<ul>
  <li>与结构不同，类实例不接收默认的成员初始化</li>
</ul>

<p>3、定义：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="c1">// class 类定义</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">SomeStructure</span> <span class="p">{</span>
    <span class="c1">// structure  结构体定义</span>
<span class="p">}</span>
</code></pre>
</div>
<p>例如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Resolution</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">height</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">VideoMode</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">resolution</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">interlaced</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">var</span> <span class="nv">frameRate</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>
</code></pre>
</div>

<p>4、实例：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someResolution</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">()</span> <span class="c1">// 结构体实例</span>
<span class="k">let</span> <span class="nv">someVideoMode</span> <span class="o">=</span> <span class="kt">VideoMode</span><span class="p">()</span>  <span class="c1">// 类的实例</span>
</code></pre>
</div>

<p>5、属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 点语法访问:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someResolution is </span><span class="se">\(</span><span class="n">someResolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someResolution is 0"</span>

<span class="c1">// 访问子属性：</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someVideoMode is </span><span class="se">\(</span><span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someVideoMode is 0"</span>

<span class="c1">// 点语法赋值</span>
<span class="c1">// 与OC不同，Swift允许直接设置结构属性的子属性</span>
<span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1280</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someVideoMode is now </span><span class="se">\(</span><span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someVideoMode is now 1280"</span>
</code></pre>
</div>

<p>6、结构体成员构造器：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 与结构不同，类实例不接收默认的成员初始化</span>
<span class="k">let</span> <span class="nv">vga</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">640</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">480</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="section-6">结构和枚举是值类型</h3>
<ul>
  <li>默认情况下，值类型的属性不能在它的实例方法中被修改；</li>
  <li>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝；</li>
  <li>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制；</li>
  <li>在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现；</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">hd</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">1920</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">1080</span><span class="p">)</span>
<span class="c1">// 将hd赋予ciname时，实际上是将hd储存的值copy给ciname，存在ciname实例中。结果就是两个完全独立的实例恰巧包含相同的数值。</span>
<span class="k">var</span> <span class="nv">cinema</span> <span class="o">=</span> <span class="n">hd</span>
<span class="n">cinema</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">2048</span>
</code></pre>
</div>
<p>枚举也遵守相同的规则</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">CompassPoint</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">currentDirection</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span>
<span class="k">let</span> <span class="nv">rememberedDirection</span> <span class="o">=</span> <span class="n">currentDirection</span>
<span class="n">currentDirection</span> <span class="o">=</span> <span class="o">.</span><span class="n">east</span>
<span class="k">if</span> <span class="n">rememberedDirection</span> <span class="o">==</span> <span class="o">.</span><span class="n">west</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The remembered direction is still .west"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "The remembered direction is still .west"</span>
</code></pre>
</div>

<h3 id="section-7">类是引用类型</h3>

<p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tenEighty</span> <span class="o">=</span> <span class="kt">VideoMode</span><span class="p">()</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">hd</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">interlaced</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"1080i"</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">frameRate</span> <span class="o">=</span> <span class="mf">25.0</span>

<span class="k">let</span> <span class="nv">alsoTenEighty</span> <span class="o">=</span> <span class="n">tenEighty</span>
<span class="n">alsoTenEighty</span><span class="o">.</span><span class="n">frameRate</span> <span class="o">=</span> <span class="mf">30.0</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"The frameRate property of tenEighty is now </span><span class="se">\(</span><span class="n">tenEighty</span><span class="o">.</span><span class="n">frameRate</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The frameRate property of tenEighty is now 30.0"</span>

<span class="c1">// 因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。</span>
</code></pre>
</div>

<p>注意：tenEighty和alsoTenEighty被声明为常量而不是变量。他们存的是指针，只要指针不改变就ok，指针指向的实例的属性是可以改变的。</p>

<h3 id="section-8">恒等运算符</h3>
<p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>

<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>

<ul>
  <li>等价于（===）  “等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li>
  <li>不等价于（!==）</li>
  <li>以上和=，!=是不同的，注意区分</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="n">tenEighty</span> <span class="o">===</span> <span class="n">alsoTenEighty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"tenEighty and alsoTenEighty refer to the same VideoMode instance."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</span>
</code></pre>
</div>
<h3 id="section-9">指针</h3>

<ul>
  <li>Swift弱化了指针的概念，其实这里的引用类型，就是指针的体现。</li>
  <li>注意Swift中的指针，与C中的指针类似，但并不直接指向某个内存地址，不要求用*来表明创建的是一个引用</li>
</ul>

<h3 id="section-10">选择类还是结构体</h3>

<ul>
  <li>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务</li>
</ul>

<p>构建结构体的条件：</p>
<ul>
  <li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
  <li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
  <li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
  <li>该数据结构不需要去继承另一个既有类型的属性或者行为。
或者：</li>
  <li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。</li>
  <li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li>
  <li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</li>
</ul>

<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>

<h3 id="section-11">字符串、数组、和字典类型的赋值与复制</h3>

<ul>
  <li>
    <p>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
  </li>
  <li>
    <p>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
  </li>
</ul>

<p>注意：
以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p>

<h1 id="properties">属性：Properties</h1>

<ul>
  <li>属性：将值跟特定的类、结构或枚举关联；</li>
  <li>存储属性：存储常量或变量作为实例的一部分。存储属性只能用于类和结构体；</li>
  <li>计算属性：计算一个值。计算属性可以用于类、结构体和枚举；</li>
  <li>类型属性：属性也可以直接作用于类型本身，这种属性称为类型属性；</li>
  <li>属性观察器：监控属性值的变化，以此来触发一个自定义的操作；</li>
  <li>属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</li>
  <li>常量属性在构造过程完成之前必须要有初始值，变量属性则无。</li>
</ul>

<h3 id="stored-properties">储存属性 Stored Properties</h3>

<p>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字var定义），也可以是常量存储属性（用关键字let定义）。</p>

<p>1、在定义属性的时候指定默认值:默认构造器</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ShoppingListItem</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">quantity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">var</span> <span class="nv">purchased</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">item</span> <span class="o">=</span> <span class="kt">ShoppingListItem</span><span class="p">()</span>
</code></pre>
</div>

<p>2、在构造过程中设置或者修改储存属性的值，甚至是常量的储存属性的值：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SurveyQuestion</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">ask</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 修改常量属性的值：</span>
<span class="k">let</span> <span class="nv">beetsQuestion</span> <span class="o">=</span> <span class="kt">SurveyQuestion</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="s">"How about beets?"</span><span class="p">)</span>
<span class="n">beetsQuestion</span><span class="o">.</span><span class="nf">ask</span><span class="p">()</span>
<span class="c1">// 打印 "How about beets?"</span>
<span class="n">beetsQuestion</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">"I also like beets. (But not with cheese.)"</span>
</code></pre>
</div>

<p>3、常量结构体的储存属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 属性</span>
<span class="kd">struct</span> <span class="kt">FixedLengthRange</span> <span class="p">{</span>
    <span class="c1">// 变量属性</span>
    <span class="k">var</span> <span class="nv">firstValue</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="c1">// 常量属性</span>
    <span class="k">let</span> <span class="nv">length</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
<span class="c1">// 使用默认构造器：</span>
<span class="k">var</span> <span class="nv">rangeOfThreeItems</span> <span class="o">=</span> <span class="kt">FixedLengthRange</span><span class="p">(</span><span class="nv">firstValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// 修改变量属性</span>
<span class="n">rangeOfThreeItems</span><span class="o">.</span><span class="n">firstValue</span> <span class="o">=</span> <span class="mi">6</span>
<span class="c1">// 不能修改常量属性，error</span>
<span class="n">rangeOfThreeItems</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">// 常量结构体:变量属性不可以修改</span>
<span class="c1">// 如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：</span>
<span class="k">let</span> <span class="nv">hd</span> <span class="o">=</span> <span class="n">rangeOfThreeItems</span>
<span class="n">hd</span><span class="o">.</span><span class="n">firstValue</span> <span class="o">=</span> <span class="mi">2048</span> 
<span class="c1">// this will report an error, even though firstValue is a variable property</span>


</code></pre>
</div>

<p>总结：</p>
<ul>
  <li>结构体是值类型；当器声明为常量的时候，其所有属性，皆是常量，皆不可修改；</li>
  <li>类则不同，他是引用类型，即便是定义为常量，也不影响修改属性；</li>
  <li>变量结构体中的常量属性，不能被修改，变量属性可以修改；</li>
  <li>常量结构体中的常变量属性皆不可修改；</li>
</ul>

<p>4、延时储存属性</p>

<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。</p>

<ul>
  <li>在属性声明前使用lazy来标示一个延迟存储属性；</li>
  <li>必须将延迟存储属性声明成变量（var），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</li>
</ul>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// DataImporter 是一个负责将外部文件中的数据导入的类。这个类的初始化会消耗不少时间。</span>
<span class="kd">class</span> <span class="kt">DataImporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">fileName</span> <span class="o">=</span> <span class="s">"data.txt"</span>
    <span class="c1">// 这里会提供数据导入功能</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">DataManager</span> <span class="p">{</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">importer</span> <span class="o">=</span> <span class="kt">DataImporter</span><span class="p">()</span>
    <span class="c1">// data属性初始值是一个空的字符串（String）数组</span>
    <span class="k">var</span> <span class="nv">data</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
    <span class="c1">// 这里会提供数据管理功能</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">manager</span> <span class="o">=</span> <span class="kt">DataManager</span><span class="p">()</span>
<span class="n">manager</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Some data"</span><span class="p">)</span>
<span class="n">manager</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Some more data"</span><span class="p">)</span>
<span class="c1">// the DataImporter instance for the importer property has not yet been created</span>

<span class="c1">// 只有使用的时候才会创建</span>
<span class="nf">print</span><span class="p">(</span><span class="n">manager</span><span class="o">.</span><span class="n">importer</span><span class="o">.</span><span class="n">fileName</span><span class="p">)</span>
<span class="c1">// Prints "data.txt"</span>
</code></pre>
</div>

<p>注意：如果一个被标记为lazy的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>

<p>5、存储属性和实例变量</p>

<p>OC为类实例存储值和引用提供两种方法，除了属性之外，还可以使用实例变量作为属性值的后端存储。</p>

<p>Swift编程语言中把这些理论统一用属性来实现。Swift中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>

<h3 id="computed-properties">计算属性 Computed Properties</h3>

<p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个getter 和一个可选的setter，来间接获取和设置其他属性或变量的值。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Point 封装了一个 (x, y) 的坐标</span>
<span class="kd">struct</span> <span class="kt">Point</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>

<span class="c1">// Size 封装了一个 width 和一个 height</span>
<span class="kd">struct</span> <span class="kt">Size</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>

<span class="c1">// Rect 表示一个有原点和尺寸的矩形</span>
<span class="kd">struct</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">origin</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">()</span>
<span class="c1">// 一个矩形的中心点可以从原点（origin）和大小（size）算出，所以不需要将它以显式声明的 Point来保存</span>
    <span class="k">var</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">Point</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">square</span> <span class="o">=</span> <span class="kt">Rect</span><span class="p">(</span><span class="nv">origin</span><span class="p">:</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span>
                  <span class="nv">size</span><span class="p">:</span> <span class="kt">Size</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="k">let</span> <span class="nv">initialSquareCenter</span> <span class="o">=</span> <span class="n">square</span><span class="o">.</span><span class="n">center</span>
<span class="n">square</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"square.origin is now at (</span><span class="se">\(</span><span class="n">square</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">square</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
<span class="c1">// Prints "square.origin is now at (10.0, 10.0)"</span>
</code></pre>
</div>

<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="" /></p>

<p>2、简化setter声明
如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。下面是使用了简化 setter 声明的 Rect 结构体代码：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">AlternativeRect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">origin</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">Point</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>3、只读属性</p>

<p>只有getter没有setter的计算属性就是只读计算属性。</p>

<ul>
  <li>只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</li>
  <li>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。</li>
  <li>let关键字只用来声明常量属性，表示初始化后再也无法修改的值。</li>
</ul>

<p>只读计算属性的声明可以去掉 get 关键字和花括号：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Cuboid</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">volume</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">fourByFiveByTwo</span> <span class="o">=</span> <span class="kt">Cuboid</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nv">depth</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"the volume of fourByFiveByTwo is </span><span class="se">\(</span><span class="n">fourByFiveByTwo</span><span class="o">.</span><span class="n">volume</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "the volume of fourByFiveByTwo is 40.0"</span>
<span class="cm">/*
结构体还有一个名为 volume 的只读计算属性用来返回立方体的体积。为 volume 提供 setter 毫无意义，因为无法确定如何修改 width、height 和 depth 三者的值来匹配新的 volume。然而，Cuboid 提供一个只读计算属性来让外部用户直接获取体积是很有用的。*/</span>
</code></pre>
</div>

<h3 id="property-observers">属性观察器 Property Observers</h3>

<p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>

<ul>
  <li>可以为除了延迟存储属性之外的其他存储属性添加属性观察器;</li>
  <li>也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器</li>
  <li>你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化</li>
</ul>

<p>可以为属性添加如下的一个或全部观察器：</p>
<ul>
  <li>
    <p>willSet 在新的值被设置之前调用:willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。</p>
  </li>
  <li>
    <p>didSet 在新的值被设置之后立即调用:didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>
  </li>
  <li>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器</li>
  <li>在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用</li>
  <li>默认值 oldValue 表示旧值的参数名。</li>
</ul>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">StepCounter</span> <span class="p">{</span>
<span class="c1">// 定义了一个 Int 类型的属性 totalSteps，它是一个存储属性，包含 willSet 和 didSet 观察器。</span>
    <span class="k">var</span> <span class="nv">totalSteps</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">willSet</span><span class="p">(</span><span class="n">newTotalSteps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"About to set totalSteps to </span><span class="se">\(</span><span class="n">newTotalSteps</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">totalSteps</span> <span class="o">&gt;</span> <span class="n">oldValue</span>  <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Added </span><span class="se">\(</span><span class="n">totalSteps</span> <span class="o">-</span> <span class="n">oldValue</span><span class="se">)</span><span class="s"> steps"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">stepCounter</span> <span class="o">=</span> <span class="kt">StepCounter</span><span class="p">()</span>
<span class="c1">// 当 totalSteps 被设置新值的时候，它的 willSet 和 didSet 观察器都会被调用，即使新值和当前值完全相同时也会被调用。</span>

<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">200</span>
<span class="c1">// About to set totalSteps to 200</span>
<span class="c1">// Added 200 steps</span>
<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">360</span>
<span class="c1">// About to set totalSteps to 360</span>
<span class="c1">// Added 160 steps</span>
<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">896</span>
<span class="c1">// About to set totalSteps to 896</span>
<span class="c1">// Added 536 steps</span>
</code></pre>
</div>

<p>注意：如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>

<h3 id="global-and-local-variables">全局变量和局部变量 Global and Local Variables</h3>

<p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<ul>
  <li>全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</li>
  <li>在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</li>
  <li>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，</li>
  <li>全局的常量或变量不需要标记lazy修饰符。</li>
  <li>局部范围的常量或变量从不延迟计算。</li>
</ul>

<h3 id="type-properties">类型属性 Type Properties</h3>

<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>

<ul>
  <li>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</li>
  <li>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。</li>
  <li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</li>
  <li>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</li>
  <li>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</li>
</ul>

<p>1、类型属性语法</p>

<p>在C或OC中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>

<p>使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 下面的例子演示了存储型和计算型类型属性的语法：</span>
<span class="kd">struct</span> <span class="kt">SomeStructure</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="kt">SomeEnumeration</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">6</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">27</span>
    <span class="p">}</span>
    <span class="kd">class</span> <span class="k">var</span> <span class="nv">overrideableComputedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">107</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>注意：
例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。</p>

<p>2、获取和设置类型属性的值</p>

<p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "Some value."</span>
<span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Another value."</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "Another value."</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeEnumeration</span><span class="o">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "6"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeClass</span><span class="o">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "27"</span>
</code></pre>
</div>

<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有 0 到 10 之间的整数音量。下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是 0，没有一个灯会亮；当声道的音量是 10，所有灯点亮。本图中，左声道的音量是 9，右声道的音量是 7
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="" /></p>

<p>上面所描述的声道模型使用 AudioChannel 结构体的实例来表示：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">AudioChannel</span> <span class="p">{</span>
    <span class="c1">// 存储型类型属性：音量的最大上限阈值</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">thresholdLevel</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="c1">// 存储型类型属性：表示所有 AudioChannel 实例的最大音量，初始值是0</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">maxInputLevelForAllChannels</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 存储型实例属,包含 didSet 属性观察器来检查每次设置后的属性值。</span>
    <span class="k">var</span> <span class="nv">currentLevel</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">thresholdLevel</span> <span class="p">{</span>
                <span class="c1">// 将当前音量限制在阀值之内</span>
                <span class="n">currentLevel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">thresholdLevel</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="p">{</span>
                <span class="c1">// 存储当前音量作为新的最大输入音量</span>
                <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="o">=</span> <span class="n">currentLevel</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可以使用结构体 AudioChannel 创建两个声道 leftChannel 和rightChannel，用以表示立体声系统的音量：</span>
<span class="k">var</span> <span class="nv">leftChannel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">rightChannel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="p">()</span>

<span class="c1">// 如果将左声道的 currentLevel 设置成 7，类型属性 maxInputLevelForAllChannels 也会更新成 7：</span>
<span class="n">leftChannel</span><span class="o">.</span><span class="n">currentLevel</span> <span class="o">=</span> <span class="mi">7</span>
<span class="nf">print</span><span class="p">(</span><span class="n">leftChannel</span><span class="o">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// Prints "7"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// Prints "7"</span>

<span class="c1">// 如果试图将右声道的 currentLevel 设置成 11，它会被修正到最大值 10，同时 maxInputLevelForAllChannels 的值也会更新到 10：</span>
<span class="n">rightChannel</span><span class="o">.</span><span class="n">currentLevel</span> <span class="o">=</span> <span class="mi">11</span>
<span class="nf">print</span><span class="p">(</span><span class="n">rightChannel</span><span class="o">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// Prints "10"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// Prints "10"</span>
</code></pre>
</div>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <span class="previous disable"><i class="fa fa-angle-double-left"></i></span>
            <span class="previous disable"><i class="fa fa-angle-left"></i></span>
          
          <span class="page_number ">1/6</span>
          
            <a href="/page2" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page6" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    最新文章
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/02/07/AD-Fastlane/">自动化测试部署系列 - Fastlane的黑魔法:自动打包编译上传 AppStore</a></li>
                    
                        <li><a href="/2017/01/23/AD-XCTest/">自动化测试部署系列 - XCTest入门</a></li>
                    
                        <li><a href="/2017/01/18/SDiffuseMenu/">Swift 版 AwesomeMenu 的改写之旅:SDiffuseMenu</a></li>
                    
                        <li><a href="/2016/12/11/swift_X_Initialization_Deinitialization/">Swift3.0_X_构造过程和析构过程 </a></li>
                    
                        <li><a href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/">Swift3.0_IX_方法、下标和继承 </a></li>
                    
                        <li><a href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/">Swift3.0_VIII_枚举、类、结构体、属性</a></li>
                    
                        <li><a href="/2016/12/07/swift_VII_Closures/">Swift3.0_VII_闭包</a></li>
                    
                        <li><a href="/2016/12/05/swift_VI_Functions/">Swift3.0_VI_函数</a></li>
                    
                        <li><a href="/2016/12/03/swift_V_Control-Flow/">Swift3.0_V_控制流</a></li>
                    
                        <li><a href="/2016/12/01/swift_IV_Collection-Types/">Swift3.0_IV_集合</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    分类
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#OS_X" class="categories-list-item" cate="OS_X">
                            <span class="name">
                                OS_X
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Objective-C" class="categories-list-item" cate="Objective-C">
                            <span class="name">
                                Objective-C
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Reverse" class="categories-list-item" cate="Reverse">
                            <span class="name">
                                Reverse
                            </span>
                            <span class="badge">9</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#AD" class="categories-list-item" cate="AD">
                            <span class="name">
                                AD
                            </span>
                            <span class="badge">6</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#tips" class="categories-list-item" cate="tips">
                            <span class="name">
                                tips
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#python" class="categories-list-item" cate="python">
                            <span class="name">
                                python
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Swift3.0" class="categories-list-item" cate="Swift3.0">
                            <span class="name">
                                Swift3.0
                            </span>
                            <span class="badge">11</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                      
                      
                      
                      
                      
                      <a href="/tag/#apache" style="font-size: 9pt; color: #999;">apache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#WKWebView、Native与JS、缓存、NSURLProtocol" style="font-size: 9pt; color: #999;">WKWebView、Native与JS、缓存、NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Charles" style="font-size: 9pt; color: #999;">Charles</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Reveal" style="font-size: 9pt; color: #999;">Reveal</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOSOpenDev" style="font-size: 9pt; color: #999;">iOSOpenDev</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#block" style="font-size: 9pt; color: #999;">block</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLProtocol" style="font-size: 9pt; color: #999;">NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#缓存" style="font-size: 10pt; color: #888;">缓存</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLCache" style="font-size: 9pt; color: #999;">NSURLCache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#SecureCRT" style="font-size: 9pt; color: #999;">SecureCRT</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#博客" style="font-size: 9pt; color: #999;">博客</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#jekyll" style="font-size: 9pt; color: #999;">jekyll</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#sublime" style="font-size: 9pt; color: #999;">sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#环境变量" style="font-size: 9pt; color: #999;">环境变量</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#mac_tips" style="font-size: 9pt; color: #999;">mac_tips</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Sublime" style="font-size: 10pt; color: #888;">Sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向" style="font-size: 9pt; color: #999;">iOS逆向</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#class_dump" style="font-size: 9pt; color: #999;">class_dump</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Theos" style="font-size: 10pt; color: #888;">Theos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Logos" style="font-size: 9pt; color: #999;">Logos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS基础" style="font-size: 9pt; color: #999;">iOS基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IDA、iFunBox、dyld_decache" style="font-size: 9pt; color: #999;">IDA、iFunBox、dyld_decache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向工具集" style="font-size: 9pt; color: #999;">iOS逆向工具集</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向理论基础" style="font-size: 9pt; color: #999;">iOS逆向理论基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#脚本" style="font-size: 9pt; color: #999;">脚本</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#python" style="font-size: 9pt; color: #999;">python</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Swift3.0" style="font-size: 18pt; color: #000;">Swift3.0</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#SDiffuseMenu" style="font-size: 9pt; color: #999;">SDiffuseMenu</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Animation" style="font-size: 9pt; color: #999;">Animation</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#XCTest" style="font-size: 9pt; color: #999;">XCTest</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#fastlane" style="font-size: 9pt; color: #999;">fastlane</a>
                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             3行代码的技术博客 
        </p>
        <p class="contact">
            Contact me at:  
            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>   -->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>-->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>        -->


        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
        
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>

          <!--   <span>
                Theme designed by <a href="https://github.com/mythkiven">MyKiven</a>.
            </span> -->

        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
  </body>

</html>
