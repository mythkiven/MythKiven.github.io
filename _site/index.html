<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>3行代码</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="/css/fontawesome/css/font-awesome.min.css ">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/">
    <link rel="alternate" type="application/rss+xml" title="3行代码" href="http://localhost:4000/feed.xml ">


<script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
     var hm = document.createElement("script");
     hm.src = "//hm.baidu.com/hm.js?d9432112fb859bf7276f8399641fb0c5";
     var s = document.getElementsByTagName("script")[0];
     s.parentNode.insertBefore(hm, s);
     })();
    </script>




    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-85978943-1', 'auto');
      ga('send', 'pageview');

    </script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">3行代码</a>
        <small>技术博客</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                
                <li>
                    
                    <a class="active" href="/">
                        
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>


                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to 3code.info!</h1>
        <small>记录生活</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/01/18/SDiffuseMenu/">Swift 版 AwesomeMenu 的改写之旅:SDiffuseMenu</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-01-18
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    

                </div>
                <div class="read-all">
                    <a  href="/2017/01/18/SDiffuseMenu/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/11/swift_X_Initialization_Deinitialization/">Swift3.0_X_构造过程和析构过程 </a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-11
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">构造过程</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">存储属性的初始赋值</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">自定义构造过程</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">默认构造器</a></li>
    </ul>
  </li>
</ul>

<h1 id="section">构造过程</h1>

<ul>
  <li>构造过程是使用类、结构体或枚举类型的实例之前的准备过程；</li>
  <li>通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法；</li>
  <li>与OC中的构造器不同，Swift的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化；</li>
  <li>类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作</li>
</ul>

<h3 id="section-1">存储属性的初始赋值</h3>

<ul>
  <li>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值；</li>
  <li>可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值；</li>
  <li>当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者</li>
</ul>

<p>1、构造器</p>

<p>以关键字init命名：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 在此处执行构造过程</span>
<span class="p">}</span>
</code></pre>
</div>

<p>案例：</p>

<p>这个结构体定义了一个不带参数的构造器init，并在里面将存储型属性temperature的值初始化为32.0</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 保存华氏温度的结构体Fahrenheit</span>
<span class="kd">struct</span> <span class="kt">Fahrenheit</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperature</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">f</span> <span class="o">=</span> <span class="kt">Fahrenheit</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The default temperature is </span><span class="se">\(</span><span class="n">f</span><span class="o">.</span><span class="n">temperature</span><span class="se">)</span><span class="s">° Fahrenheit"</span><span class="p">)</span>
<span class="c1">// 打印 "The default temperature is 32.0° Fahrenheit”</span>
</code></pre>
</div>

<p>2、默认属性值</p>

<p>如前所述，可以在构造器中为存储型属性设置初始值。同样，也可以在属性声明时为其设置默认值</p>

<p>注意：如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能充分利用默认构造器、构造器继承等特性，后续章节将讲到。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：</span>
<span class="kd">struct</span> <span class="kt">Fahrenheit</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="section-2">自定义构造过程</h3>

<p>可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。</p>

<p>1、构造参数：</p>

<p>自定义构造过程时，可以在定义中提供构造参数，指定所需值的类型和名字。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：</span>

<span class="kd">struct</span> <span class="kt">Celsius</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperatureInCelsius</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="c1">// 构造参数，其外部名字为fromFahrenheit,内部名字为fahrenheit</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nv">fahrenheit</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
    <span class="p">}</span>
    <span class="c1">// 构造参数，其外部名字为fromKelvin，内部名字为kelvin</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nv">kelvin</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">boilingPointOfWater</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="nv">fromFahrenheit</span><span class="p">:</span> <span class="mf">212.0</span><span class="p">)</span>
<span class="c1">// boilingPointOfWater.temperatureInCelsius 是 100.0</span>
<span class="k">let</span> <span class="nv">freezingPointOfWater</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="nv">fromKelvin</span><span class="p">:</span> <span class="mf">273.15</span><span class="p">)</span>
<span class="c1">// freezingPointOfWater.temperatureInCelsius 是 0.0</span>
</code></pre>
</div>

<p>2、参数的内部名称和外部名称：</p>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>当中有多个构造器时，需要通过外部名称来识别不同的构造器：在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>

<p>以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。</span>

<span class="kd">struct</span> <span class="kt">Color</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">red</span>   <span class="o">=</span> <span class="n">red</span>
        <span class="k">self</span><span class="o">.</span><span class="n">green</span> <span class="o">=</span> <span class="n">green</span>
        <span class="k">self</span><span class="o">.</span><span class="n">blue</span>  <span class="o">=</span> <span class="n">blue</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">white</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">red</span>   <span class="o">=</span> <span class="n">white</span>
        <span class="n">green</span> <span class="o">=</span> <span class="n">white</span>
        <span class="n">blue</span>  <span class="o">=</span> <span class="n">white</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>两种构造器都能用于创建一个新的Color实例，你需要为构造器每个外部参数传值：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">magenta</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">halfGray</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="nv">white</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">)</span>
</code></pre>
</div>
<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">veryGreen</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="c1">// 报编译时错误，需要外部名称</span>
</code></pre>
</div>

<p>3、不带外部名的构造器参数：</p>

<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">下面是之前Celsius例子的扩展</span><span class="err">，</span><span class="n">跟之前相比添加了一个带有Double类型参数的构造器</span><span class="err">，</span><span class="n">其外部名用_代替</span><span class="err">：</span>

<span class="kd">struct</span> <span class="kt">Celsius</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">temperatureInCelsius</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nv">fahrenheit</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nv">kelvin</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">celsius</span><span class="p">:</span> <span class="kt">Double</span><span class="p">){</span>
        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">celsius</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">bodyTemperature</span> <span class="o">=</span> <span class="kt">Celsius</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
<span class="c1">// bodyTemperature.temperatureInCelsius 为 37.0</span>
<span class="c1">// 调用Celsius(37.0)意图明确，不需要外部参数名称。</span>
</code></pre>
</div>

<p>4、可选属性类型</p>

<p>如果定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。</p>

<p>下面例子中定义了类SurveyQuestion，它包含一个可选字符串属性response：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SurveyQuestion</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">ask</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">cheeseQuestion</span> <span class="o">=</span> <span class="kt">SurveyQuestion</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="s">"Do you like cheese?"</span><span class="p">)</span>
<span class="n">cheeseQuestion</span><span class="o">.</span><span class="nf">ask</span><span class="p">()</span>
<span class="c1">// 打印 "Do you like cheese?"</span>
<span class="n">cheeseQuestion</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">"Yes, I do like cheese."</span>

<span class="c1">// 调查问题的答案在回答前是无法确定的，因此我们将属性response声明为String?类型，或者说是可选字符串类型。当SurveyQuestion实例化时，它将自动赋值为nil，表明此字符串暂时还没有值。</span>
</code></pre>
</div>

<p>5、构造过程中常量属性的修改</p>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>

<p>注意：对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>

<h3 id="section-3">默认构造器</h3>

<p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>

<p>案例:下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ShoppingListItem</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">quantity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">var</span> <span class="nv">purchased</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">item</span> <span class="o">=</span> <span class="kt">ShoppingListItem</span><span class="p">()</span>
</code></pre>
</div>
<p>由于ShoppingListItem类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为name属性设置默认值，但由于name是可选字符串类型，它将默认设置为nil）。上面例子中使用默认构造器创造了一个ShoppingListItem类的实例（使用ShoppingListItem()形式的构造器语法），并将其赋值给变量item。</p>

<p>2、结构体的逐一成员构造器</p>

<p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>

<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 结构体Size自动获得了一个逐一成员构造器init(width:height:)。你可以用它来为Size创建新的实例：</span>

<span class="kd">struct</span> <span class="kt">Size</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">twoByTwo</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
</code></pre>
</div>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/11/swift_X_Initialization_Deinitialization/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/">Swift3.0_IX_方法、下标和继承 </a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-10
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#methods" id="markdown-toc-methods">方法 Methods</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">类型方法</a></li>
    </ul>
  </li>
  <li><a href="#subscripts" id="markdown-toc-subscripts">下标 Subscripts</a></li>
  <li><a href="#inheritance" id="markdown-toc-inheritance">继承 Inheritance</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">定义基类</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">子类生成</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">重写</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">防止重写</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="methods">方法 Methods</h1>

<p>方法是与某些特定类型相关联的函数。</p>

<ul>
  <li>类、结构体、枚举都可以定义实例方法；</li>
  <li>
    <p>实例方法为给定类型的实例封装了具体的任务与功能；</p>
  </li>
  <li>类、结构体、枚举也可以定义类型方法；</li>
  <li>
    <p>类型方法与类型本身相关联，与 OC中的类方法类似；</p>
  </li>
  <li>结构体和枚举能够定义方法是 Swift 与 C/OC的主要区别之一；</li>
  <li>在OC中，类是唯一能定义方法的类型；；</li>
  <li>但在Swift中，不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在创建的类型（类/结构体/枚举）上定义方法。</li>
</ul>

<p>1、实例方法</p>

<ul>
  <li>实例方法是属于某个特定类、结构体或者枚举类型实例的方法；</li>
  <li>实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致</li>
  <li>实例方法要写在它所属的类型的前后大括号之间</li>
  <li>实例方法能够隐式访问它所属类型的所有的其他实例方法和属性</li>
  <li>实例方法只能被它所属的类的某个特定实例调用</li>
  <li>实例方法不能脱离于现存的实例而被调用
案例：</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Counter类，它可用于计算次数的动作时发生的数量：</span>

<span class="kd">class</span> <span class="kt">Counter</span> <span class="p">{</span>
    <span class="c1">// 本Counter类还声明一个变量属性count，以跟踪当前计数器值。</span>
    <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 实例方法:increment()递增计数器1</span>
    <span class="kd">func</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// 实例方法:increment(by: Int) 将计数器增加指定的整数值</span>
    <span class="kd">func</span> <span class="nf">increment</span><span class="p">(</span><span class="n">by</span> <span class="nv">amount</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">amount</span>
    <span class="p">}</span>
    <span class="c1">// reset() 将计数器重置为零</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">counter</span> <span class="o">=</span> <span class="kt">Counter</span><span class="p">()</span>
<span class="c1">// the initial counter value is 0</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">increment</span><span class="p">()</span>
<span class="c1">// the counter's value is now 1</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">increment</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// the counter's value is now 6</span>
<span class="n">counter</span><span class="o">.</span><span class="nf">reset</span><span class="p">()</span>
<span class="c1">// the counter's value is now 0</span>
</code></pre>
</div>

<p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用）(通过参数标签，参数名称是实现)。方法参数也一样，因为方法就是函数，只是这个函数与某个类型相关联了。</p>

<p>2、 self属性</p>

<ul>
  <li>类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身；</li>
  <li>你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例；</li>
  <li>一般不用在类型实例里面写self,Swift默认指当前实例的属性或者方法；</li>
  <li>一般使用self用于严谨的区分参数和属性。
```swift
// 上面例子中的increment方法还可以这样写：
func increment() {
  self.count += 1
}</li>
</ul>

<p>// 区分参数和属性
struct Point {
    // x,y是属性
    var x = 0.0, y = 0.0
    // x是参数
    func isToTheRightOfX(x: Double) -&gt; Bool {
        // 要进行区分:否则Swift会认为X都是参数。
        return self.x &gt; x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOfX(1.0) {
    print(“This point is to the right of the line where x == 1.0”)
}
// 打印 “This point is to the right of the line where x == 1.0”</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
3、在实例方法中修改值类型

- 结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改；
- 但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；
- 并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中；
- 方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例；
- 要使用可变方法，将关键字mutating 放到方法的func关键字之前就可以了：

```swift
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// Prints "The point is now at (3.0, 4.0)"
</code></pre>
</div>

<p>注意：不能在结构体类型的常量类型上调用可变方法，因为其属性不能被改变，即使属性是变量属性。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">fixedPoint</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="n">fixedPoint</span><span class="o">.</span><span class="nf">moveByX</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="c1">// 这里将会报告一个错误</span>
</code></pre>
</div>

<p>4、在可变方法中给self赋值</p>

<p>可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Point</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">moveBy</span><span class="p">(</span><span class="n">x</span> <span class="nv">deltaX</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="n">y</span> <span class="nv">deltaY</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">deltaX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">deltaY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 新版的可变方法moveBy(x:y:)创建了一个新的结构体实例，它的 x 和 y 的值都被设定为目标值。调用这个版本的方法和调用上个版本的最终结果是一样的。</span>
</code></pre>
</div>

<p>枚举的可变方法可以把self设置为同一枚举类型中不同的成员：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">TriStateSwitch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Off</span><span class="p">,</span> <span class="kt">Low</span><span class="p">,</span> <span class="kt">High</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">Off</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Low</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">Low</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">High</span>
        <span class="k">case</span> <span class="o">.</span><span class="kt">High</span><span class="p">:</span>
            <span class="k">self</span> <span class="o">=</span> <span class="o">.</span><span class="kt">Off</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">ovenLight</span> <span class="o">=</span> <span class="kt">TriStateSwitch</span><span class="o">.</span><span class="kt">Low</span>
<span class="n">ovenLight</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// ovenLight 现在等于 .High</span>
<span class="n">ovenLight</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span>
<span class="c1">// ovenLight 现在等于 .Off</span>
</code></pre>
</div>
<p>上面的例子中定义了一个三态开关的枚举。每次调用next()方法时，开关在不同的电源状态（Off，Low，High）之间循环切换。</p>

<h3 id="section">类型方法</h3>

<ul>
  <li>实例方法是被某个类型的实例调用的方法；</li>
  <li>也可以定义在类型本身上调用的方法，这种方法就叫做类型方法；</li>
  <li>在方法的func关键字之前加上关键字static，来指定类型方法；</li>
  <li>类还可以用关键字class来允许子类重写父类的方法实现；</li>
  <li>类型方法和实例方法一样用点语法调用；</li>
</ul>

<p>注意：
在OC中，只能为OC的类类型（classes）定义类型方法。在Swift中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="kd">func</span> <span class="nf">someTypeMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 在这里实现类型方法</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">SomeClass</span><span class="o">.</span><span class="nf">someTypeMethod</span><span class="p">()</span>
</code></pre>
</div>

<ul>
  <li>在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例；</li>
  <li>这意味着可以用self来消除类型属性和类型方法参数之间的歧义；</li>
  <li>一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称；</li>
  <li>类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称；</li>
</ul>

<p>案例：
下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</span>

<span class="kd">struct</span> <span class="kt">LevelTracker</span> <span class="p">{</span>
    <span class="c1">// 类型属性：highestUnlockedLevel监测玩家已解锁的最高等级</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">highestUnlockedLevel</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">// 实例属性:currentLevel来监测每个玩家当前的等级</span>
    <span class="k">var</span> <span class="nv">currentLevel</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">// 类型方法：一旦新等级被解锁，它会更新highestUnlockedLevel的值</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">_</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">highestUnlockedLevel</span> <span class="p">{</span> <span class="n">highestUnlockedLevel</span> <span class="o">=</span> <span class="n">level</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 如果某个给定的等级已经被解锁，它将返回true</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">isUnlocked</span><span class="p">(</span><span class="n">_</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// 尽管没有使用类似LevelTracker.highestUnlockedLevel的写法，这个类型方法还是能够访问类型属性highestUnlockedLevel</span>
        <span class="k">return</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">highestUnlockedLevel</span>
    <span class="p">}</span>
    
    <span class="c1">// 实例方法，管理currentLevel属性</span>
    <span class="c1">// 这个方法会在更新currentLevel之前检查所请求的新等级是否已经解锁</span>
    <span class="kd">@discardableResult</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">advance</span><span class="p">(</span><span class="n">to</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="kt">LevelTracker</span><span class="o">.</span><span class="nf">isUnlocked</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">currentLevel</span> <span class="o">=</span> <span class="n">level</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 在调用advance(to:)时候忽略返回值，不会产生编译警告，所以函数被标注为@ discardableResult属性</span>
    <span class="c1">//@discardableResult 将此属性应用于函数或方法声明以在不使用其结果的情况下调用返回值的函数或方法时抑制编译器警告。</span>
<span class="p">}</span>
</code></pre>
</div>

<p>下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Player</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">tracker</span> <span class="o">=</span> <span class="kt">LevelTracker</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">playerName</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="nf">complete</span><span class="p">(</span><span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">LevelTracker</span><span class="o">.</span><span class="nf">unlock</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tracker</span><span class="o">.</span><span class="nf">advance</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">playerName</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。</p>

<p>还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">player</span> <span class="o">=</span> <span class="kt">Player</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Argyrios"</span><span class="p">)</span>
<span class="n">player</span><span class="o">.</span><span class="nf">complete</span><span class="p">(</span><span class="nv">level</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"highest unlocked level is now </span><span class="se">\(</span><span class="kt">LevelTracker</span><span class="o">.</span><span class="n">highestUnlockedLevel</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "highest unlocked level is now 2"</span>
</code></pre>
</div>

<h1 id="subscripts">下标 Subscripts</h1>

<ul>
  <li>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式；</li>
  <li>可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法；</li>
  <li>举例：用下标访问一个Array实例中的元素可以写作someArray[index]；</li>
  <li>举例：访问Dictionary实例中的元素可以写作someDictionary[key]；</li>
  <li>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</li>
</ul>

<p>1、下标语法</p>

<p>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标使用subscript关键字，指定一个或多个输入参数和返回类型；与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
      <span class="c1">// 返回一个适当的 Int 类型的值</span>
    <span class="p">}</span>

    <span class="nf">set</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 执行适当的赋值操作</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数</span>
</code></pre>
</div>

<p>只读下标：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 如同只读计算型属性，可以省略只读下标的get关键字：</span>
<span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="c1">// 返回一个适当的 Int 类型的值</span>
<span class="p">}</span>
</code></pre>
</div>

<p>只读下标的实现：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 这里定义了一个TimesTable结构体，用来表示传入整数的乘法表：</span>
<span class="kd">struct</span> <span class="kt">TimesTable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">multiplier</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">multiplier</span> <span class="o">*</span> <span class="n">index</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">threeTimesTable</span> <span class="o">=</span> <span class="kt">TimesTable</span><span class="p">(</span><span class="nv">multiplier</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"six times three is </span><span class="se">\(</span><span class="n">threeTimesTable</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "six times three is 18"</span>

<span class="c1">// 在上例中，创建了一个TimesTable实例，用来表示整数3的乘法表。数值3被传递给结构体的构造函数，作为实例成员multiplier的值。</span>
</code></pre>
</div>

<p>2、下标用法</p>

<p>下标的确切含义取决于使用场景。下标通常作为访问集合，列表或序列中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标。</p>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Swift 的Dictionary类型实现下标用于对其实例中储存的值进行存取操作。为字典设值时，在下标中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标：</span>

<span class="k">var</span> <span class="nv">numberOfLegs</span> <span class="o">=</span> <span class="p">[</span><span class="s">"spider"</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">"ant"</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s">"cat"</span><span class="p">:</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">numberOfLegs</span><span class="p">[</span><span class="s">"bird"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre>
</div>
<p>注意:Swift 的Dictionary类型的下标接受并返回可选类型的值。上例中的numberOfLegs字典通过下标返回的是一个Int?或者说“可选的int”。Dictionary类型之所以如此实现下标，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。</p>

<p>3、下标选项</p>

<p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>

<p>下标的重载：一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是下标的重载。</p>

<p>虽然接受单一入参的下标是最常见的，但也可以根据情况定义接受多个入参的下标。例如下例定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵。Matrix结构体的下标接受两个整型参数：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Matrix</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rows</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">grid</span><span class="p">:</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">rows</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="k">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">columns</span><span class="p">,</span> <span class="nv">repeatedValue</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">columns</span>
    <span class="p">}</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="nf">assert</span><span class="p">(</span><span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="n">column</span><span class="p">),</span> <span class="s">"Index out of range"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="nf">assert</span><span class="p">(</span><span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="n">column</span><span class="p">),</span> <span class="s">"Index out of range"</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Matrix提供了一个接受两个入参的构造方法，入参分别是rows和columns，创建了一个足够容纳rows * columns个Double类型的值的数组。通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0</p>

<p>你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">matrix</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">(</span><span class="nv">rows</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">columns</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>
<p>上例中创建了一个Matrix实例来表示两行两列的矩阵。该Matrix实例的grid数组按照从左上到右下的阅读顺序将矩阵扁平化存储：
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png" alt="" /></p>

<p>将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.2</span>
</code></pre>
</div>
<p>上面两条语句分别调用下标的 setter 将矩阵右上角位置（即row为0、column为1的位置）的值设置为1.5，将矩阵左下角位置（即row为1、column为0的位置）的值设置为3.2：</p>

<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png" alt="" /></p>

<p>Matrix下标的 getter 和 setter 中都含有断言，用来检查下标入参row和column的值是否有效。为了方便进行断言，Matrix包含了一个名为indexIsValidForRow(_:column:)的便利方法，用来检查入参row和column的值是否在矩阵范围内：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">indexIsValidForRow</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">column</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">columns</span>
<span class="p">}</span>
</code></pre>
</div>
<p>断言在下标越界时触发：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someValue</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="c1">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span>
</code></pre>
</div>

<h1 id="inheritance">继承 Inheritance</h1>

<p>一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>

<p>在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>

<p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>

<h3 id="section-1">定义基类</h3>

<p>不继承于其它类的类，称之为基类。</p>

<p>注意：Swift中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Vehicle基类也定义了一个名为makeNoise的方法。这个方法实际上不为Vehicle实例做任何事，但之后将会被Vehicle的子类定制：</span>

<span class="kd">class</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentSpeed</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"traveling at </span><span class="se">\(</span><span class="n">currentSpeed</span><span class="se">)</span><span class="s"> miles per hour"</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">makeNoise</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 什么也不做-因为车辆不一定会有噪音</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>可以用初始化语法创建一个Vehicle的新实例，即类名后面跟一个空括号</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someVehicle</span> <span class="o">=</span> <span class="kt">Vehicle</span><span class="p">()</span>
</code></pre>
</div>

<h2 id="section-2">子类生成</h2>

<p>子类生成指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span><span class="p">:</span> <span class="kt">SomeSuperclass</span> <span class="p">{</span>
    <span class="c1">// 这里是子类的定义</span>
<span class="p">}</span>
</code></pre>
</div>
<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Bicycle</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">hasBasket</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">bicycle</span> <span class="o">=</span> <span class="kt">Bicycle</span><span class="p">()</span>
<span class="n">bicycle</span><span class="o">.</span><span class="n">hasBasket</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// 可以修改Bicycle实例所继承的currentSpeed属性，和查询实例所继承的description属性：</span>
<span class="n">bicycle</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">15.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Bicycle: </span><span class="se">\(</span><span class="n">bicycle</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "Bicycle: traveling at 15.0 miles per hour"</span>

<span class="c1">// 子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：</span>
<span class="kd">class</span> <span class="kt">Tandem</span><span class="p">:</span> <span class="kt">Bicycle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentNumberOfPassengers</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">tandem</span> <span class="o">=</span> <span class="kt">Tandem</span><span class="p">()</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">hasBasket</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">currentNumberOfPassengers</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">tandem</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">22.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Tandem: </span><span class="se">\(</span><span class="n">tandem</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印："Tandem: traveling at 22.0 miles per hour"</span>
</code></pre>
</div>

<h3 id="section-3">重写</h3>

<p>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。这种行为叫重写。</p>

<p>如果要重写某个特性，需要在重写定义的前面加上override关键字。这么做，就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少override关键字的重写都会在编译时被诊断为错误。</p>

<p>override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>

<p>1、 访问超类的方法，属性及下标</p>

<p>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>

<p>在合适的地方，你可以通过使用super前缀来访问超类版本的方法，属性或下标：</p>
<ul>
  <li>在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。</li>
  <li>在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。</li>
  <li>在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。</li>
</ul>

<p>2、重写方法</p>

<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法</span>
<span class="kd">class</span> <span class="kt">Train</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">makeNoise</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Choo Choo"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>3、重写属性</p>

<p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>

<ul>
  <li>可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可；</li>
  <li>但是，不可以将一个继承来的读写属性重写为一个只读属性；</li>
  <li>提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性；</li>
  <li>子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型；</li>
  <li>在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的；</li>
</ul>

<p>注意
如果在重写属性中提供了setter，那么也一定要提供getter。如果不想在重写版本中的getter里修改继承来的属性值，可以直接通过super.someProperty来返回继承来的值，其中someProperty是要重写的属性的名字。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Car</span><span class="p">:</span> <span class="kt">Vehicle</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">gear</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">super</span><span class="o">.</span><span class="n">description</span> <span class="o">+</span> <span class="s">" in gear </span><span class="se">\(</span><span class="n">gear</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 重写的description属性首先要调用super.description返回Vehicle类的description属性。之后，Car类版本的description在末尾增加了一些额外的文本来提供关于当前档位的信息。</span>
</code></pre>
</div>

<p>4、重写属性观察器</p>

<p>可以通过重写属性为一个继承来的属性添加属性观察器。当继承来的属性值发生改变时，就会被通知到，无论那个属性原本是如何实现的。</p>

<p>注意：不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。
此外还要注意，不可以同时提供重写的 setter 和重写的属性观察器。如果想观察属性值的变化，并且已经为那个属性提供了定制的 setter，那么在 setter 中就可以观察到任何值变化了。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</span>
<span class="kd">class</span> <span class="kt">AutomaticCar</span><span class="p">:</span> <span class="kt">Car</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">var</span> <span class="nv">currentSpeed</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">gear</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">currentSpeed</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
当你设置AutomaticCar的currentSpeed属性，属性的didSet观察器就会自动地设置gear属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位gear的值。例如，速度为35.0时，挡位为4：
*/</span>

<span class="k">let</span> <span class="nv">automatic</span> <span class="o">=</span> <span class="kt">AutomaticCar</span><span class="p">()</span>
<span class="n">automatic</span><span class="o">.</span><span class="n">currentSpeed</span> <span class="o">=</span> <span class="mf">35.0</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"AutomaticCar: </span><span class="se">\(</span><span class="n">automatic</span><span class="o">.</span><span class="n">description</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// 打印 "AutomaticCar: traveling at 35.0 miles per hour in gear 4"</span>
</code></pre>
</div>

<h3 id="section-4">防止重写</h3>

<p>可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。</p>

<p>如果重写了带有final标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final 的。</p>

<p>可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/">Swift3.0_VIII_枚举、类、结构体、属性</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-08
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">枚举</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">枚举语法：</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">原始值</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">递归枚举</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">类和结构体</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">类和结构体的对比</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">结构和枚举是值类型</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">类是引用类型</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">恒等运算符</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">指针</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">选择类还是结构体</a></li>
      <li><a href="#section-11" id="markdown-toc-section-11">字符串、数组、和字典类型的赋值与复制</a></li>
    </ul>
  </li>
  <li><a href="#properties" id="markdown-toc-properties">属性：Properties</a>    <ul>
      <li><a href="#stored-properties" id="markdown-toc-stored-properties">储存属性 Stored Properties</a></li>
      <li><a href="#computed-properties" id="markdown-toc-computed-properties">计算属性 Computed Properties</a></li>
      <li><a href="#property-observers" id="markdown-toc-property-observers">属性观察器 Property Observers</a></li>
      <li><a href="#global-and-local-variables" id="markdown-toc-global-and-local-variables">全局变量和局部变量 Global and Local Variables</a></li>
      <li><a href="#type-properties" id="markdown-toc-type-properties">类型属性 Type Properties</a></li>
    </ul>
  </li>
</ul>

<p>枚举为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>

<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>

<h1 id="section">枚举</h1>

<h3 id="section-1">枚举语法：</h3>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">SomeEnumeration</span> <span class="p">{</span>
    <span class="c1">// enumeration definition goes here</span>
<span class="p">}</span>
</code></pre>
</div>

<p>指南针案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">CompassPoint</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">north</span>
    <span class="k">case</span> <span class="n">south</span>
    <span class="k">case</span> <span class="n">east</span>
    <span class="k">case</span> <span class="n">west</span>
<span class="p">}</span>
</code></pre>
</div>

<p>注意
与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。</p>

<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Planet</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercury</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">earth</span><span class="p">,</span> <span class="n">mars</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturn</span><span class="p">,</span> <span class="n">uranus</span><span class="p">,</span> <span class="n">neptune</span>
<span class="p">}</span>
</code></pre>
</div>

<p>可以这样使用：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">directionToHead</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span>
</code></pre>
</div>

<p>当directionToHead的类型已知时，再次为其赋值可以使用更简短的点语法：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">directionToHead</span> <span class="o">=</span> <span class="o">.</span><span class="n">east</span>
</code></pre>
</div>

<p>使用 Switch 语句匹配枚举值</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">directionToHead</span> <span class="o">=</span> <span class="o">.</span><span class="n">south</span>
<span class="k">switch</span> <span class="n">directionToHead</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">north</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Lots of planets have a north"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">south</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Watch out for penguins"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">east</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Where the sun rises"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">west</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Where the skies are blue"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "Watch out for penguins"</span>
</code></pre>
</div>

<p>当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">somePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="o">.</span><span class="n">earth</span>
<span class="k">switch</span> <span class="n">somePlanet</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">earth</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Mostly harmless"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 打印 "Mostly harmless”</span>
</code></pre>
</div>

<p>在 Swift 中，使用如下方式定义表示两种商品条形码(条形码、QR码)的枚举：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Barcode</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">upc</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">qrCode</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// “定义一个名为Barcode的枚举类型，它的一个成员值是具有(Int，Int，Int，Int)类型关联值的upc，另一个成员值是具有String类型关联值的qrCode。”</span>
</code></pre>
</div>

<p>然后可以使用任意一种条形码类型创建新的条形码，例如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">productBarcode</span> <span class="o">=</span> <span class="kt">Barcode</span><span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// 创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)。</span>

<span class="c1">// 同一个商品可以被分配一个不同类型的条形码，例如：</span>
<span class="n">productBarcode</span> <span class="o">=</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="s">"ABCDEFGHIJKLMNOP"</span><span class="p">)</span>

<span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="k">let</span> <span class="nv">numberSystem</span><span class="p">,</span> <span class="k">let</span> <span class="nv">manufacturer</span><span class="p">,</span> <span class="k">let</span> <span class="nv">product</span><span class="p">,</span> <span class="k">let</span> <span class="nv">check</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"UPC: </span><span class="se">\(</span><span class="n">numberSystem</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">manufacturer</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">product</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">check</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="k">let</span> <span class="nv">productCode</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"QR code: </span><span class="se">\(</span><span class="n">productCode</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "QR code: ABCDEFGHIJKLMNOP."</span>

<span class="c1">// 如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</span>
<span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">upc</span><span class="p">(</span><span class="n">numberSystem</span><span class="p">,</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">check</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"UPC: </span><span class="se">\(</span><span class="n">numberSystem</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">manufacturer</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">product</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">check</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">qrCode</span><span class="p">(</span><span class="n">productCode</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"QR code: </span><span class="se">\(</span><span class="n">productCode</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span>
</code></pre>
</div>

<h3 id="section-2">原始值</h3>

<p>枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">ASCIIControlCharacter</span><span class="p">:</span> <span class="kt">Character</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tab</span> <span class="o">=</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span>
    <span class="k">case</span> <span class="n">lineFeed</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
    <span class="k">case</span> <span class="n">carriageReturn</span> <span class="o">=</span> <span class="s">"</span><span class="se">\r</span><span class="s">"</span>
<span class="p">}</span>
<span class="c1">// 枚举类型ASCIIControlCharacter的原始值类型被定义为Character，并设置了一些比较常见的 ASCII 控制字符</span>
</code></pre>
</div>

<p>原始值的隐式赋值</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Planet</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercury</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">earth</span><span class="p">,</span> <span class="n">mars</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturn</span><span class="p">,</span> <span class="n">uranus</span><span class="p">,</span> <span class="n">neptune</span>
<span class="p">}</span>
<span class="c1">//  venus == 2  earth ==3...</span>
</code></pre>
</div>

<p>使用枚举成员的rawValue属性可以访问该枚举成员的原始值：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">earthsOrder</span> <span class="o">=</span> <span class="kt">Planet</span><span class="o">.</span><span class="n">earth</span><span class="o">.</span><span class="n">rawValue</span>
<span class="c1">// earthsOrder is 3</span>
 
<span class="k">let</span> <span class="nv">sunsetDirection</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span><span class="o">.</span><span class="n">rawValue</span>
<span class="c1">// sunsetDirection is "west"</span>
</code></pre>
</div>

<p>使用原始值初始化枚举实例</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">possiblePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">// possiblePlanet is of type Planet? and equals Planet.uranus</span>
<span class="c1">// possiblePlanet是Planet?类型，或者说“可选的Planet”。</span>
</code></pre>
</div>

<p>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：</span>

<span class="k">let</span> <span class="nv">positionToFind</span> <span class="o">=</span> <span class="mi">11</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">somePlanet</span> <span class="o">=</span> <span class="kt">Planet</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">positionToFind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">somePlanet</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">earth</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Mostly harmless"</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Not a safe place for humans"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"There isn't a planet at position </span><span class="se">\(</span><span class="n">positionToFind</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "There isn't a planet at position 11"</span>
</code></pre>
</div>

<h3 id="section-3">递归枚举</h3>

<p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 在枚举成员前加上indirect来表示该成员可递归。</span>
<span class="kd">enum</span> <span class="kt">ArithmeticExpression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">number</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">addition</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">multiplication</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：</span>
<span class="kd">indirect</span> <span class="kd">enum</span> <span class="kt">ArithmeticExpression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">number</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">addition</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">multiplication</span><span class="p">(</span><span class="kt">ArithmeticExpression</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 应用：</span>
<span class="k">let</span> <span class="nv">five</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">four</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">addition</span><span class="p">(</span><span class="n">five</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">product</span> <span class="o">=</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">multiplication</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="kt">ArithmeticExpression</span><span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="c1">// 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式</span>
<span class="kd">func</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">_</span> <span class="nv">expression</span><span class="p">:</span> <span class="kt">ArithmeticExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">expression</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">number</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">addition</span><span class="p">(</span><span class="k">left</span><span class="p">,</span> <span class="k">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">right</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">multiplication</span><span class="p">(</span><span class="k">left</span><span class="p">,</span> <span class="k">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">left</span><span class="p">)</span> <span class="o">*</span> <span class="nf">evaluate</span><span class="p">(</span><span class="k">right</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">product</span><span class="p">))</span>
<span class="c1">// 打印 "18"</span>
</code></pre>
</div>

<h1 id="section-4">类和结构体</h1>

<p>与其他编程语言所不同的是，Swift 并不要求为自定义类和结构去创建独立的接口和实现文件。只需要在单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>

<h3 id="section-5">类和结构体的对比</h3>

<p>1、共同点：</p>

<ul>
  <li>定义要存储值的属性</li>
  <li>定义方法以提供功能</li>
  <li>定义下标，以使用下标语法访问其值</li>
  <li>定义初始化程序以设置其初始状态</li>
  <li>扩展其功能超出默认实现</li>
  <li>符合协议以提供某种类型的标准功能</li>
</ul>

<p>2、类独有功能：</p>

<ul>
  <li>继承使一个类能够继承另一个类的特性。</li>
  <li>类型转换使您能够在运行时检查和解释类实例的类型。</li>
  <li>Deinitializers使一个类的实例释放它分配的任何资源。</li>
  <li>引用计数允许对类实例的多个引用。</li>
</ul>

<p>注意：结构在code中传递并不会使用引用计数：Structures are always copied when they are passed around in your code, and do not use reference counting.</p>

<p>不同之处：</p>

<ul>
  <li>与结构不同，类实例不接收默认的成员初始化</li>
</ul>

<p>3、定义：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="c1">// class 类定义</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">SomeStructure</span> <span class="p">{</span>
    <span class="c1">// structure  结构体定义</span>
<span class="p">}</span>
</code></pre>
</div>
<p>例如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Resolution</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">height</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">VideoMode</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">resolution</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">interlaced</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">var</span> <span class="nv">frameRate</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>
</code></pre>
</div>

<p>4、实例：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someResolution</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">()</span> <span class="c1">// 结构体实例</span>
<span class="k">let</span> <span class="nv">someVideoMode</span> <span class="o">=</span> <span class="kt">VideoMode</span><span class="p">()</span>  <span class="c1">// 类的实例</span>
</code></pre>
</div>

<p>5、属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 点语法访问:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someResolution is </span><span class="se">\(</span><span class="n">someResolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someResolution is 0"</span>

<span class="c1">// 访问子属性：</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someVideoMode is </span><span class="se">\(</span><span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someVideoMode is 0"</span>

<span class="c1">// 点语法赋值</span>
<span class="c1">// 与OC不同，Swift允许直接设置结构属性的子属性</span>
<span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1280</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"The width of someVideoMode is now </span><span class="se">\(</span><span class="n">someVideoMode</span><span class="o">.</span><span class="n">resolution</span><span class="o">.</span><span class="n">width</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The width of someVideoMode is now 1280"</span>
</code></pre>
</div>

<p>6、结构体成员构造器：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 与结构不同，类实例不接收默认的成员初始化</span>
<span class="k">let</span> <span class="nv">vga</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">640</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">480</span><span class="p">)</span>
</code></pre>
</div>

<h3 id="section-6">结构和枚举是值类型</h3>
<ul>
  <li>默认情况下，值类型的属性不能在它的实例方法中被修改；</li>
  <li>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝；</li>
  <li>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制；</li>
  <li>在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现；</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">hd</span> <span class="o">=</span> <span class="kt">Resolution</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">1920</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">1080</span><span class="p">)</span>
<span class="c1">// 将hd赋予ciname时，实际上是将hd储存的值copy给ciname，存在ciname实例中。结果就是两个完全独立的实例恰巧包含相同的数值。</span>
<span class="k">var</span> <span class="nv">cinema</span> <span class="o">=</span> <span class="n">hd</span>
<span class="n">cinema</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">2048</span>
</code></pre>
</div>
<p>枚举也遵守相同的规则</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">CompassPoint</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">currentDirection</span> <span class="o">=</span> <span class="kt">CompassPoint</span><span class="o">.</span><span class="n">west</span>
<span class="k">let</span> <span class="nv">rememberedDirection</span> <span class="o">=</span> <span class="n">currentDirection</span>
<span class="n">currentDirection</span> <span class="o">=</span> <span class="o">.</span><span class="n">east</span>
<span class="k">if</span> <span class="n">rememberedDirection</span> <span class="o">==</span> <span class="o">.</span><span class="n">west</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The remembered direction is still .west"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "The remembered direction is still .west"</span>
</code></pre>
</div>

<h3 id="section-7">类是引用类型</h3>

<p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tenEighty</span> <span class="o">=</span> <span class="kt">VideoMode</span><span class="p">()</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">hd</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">interlaced</span> <span class="o">=</span> <span class="kc">true</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"1080i"</span>
<span class="n">tenEighty</span><span class="o">.</span><span class="n">frameRate</span> <span class="o">=</span> <span class="mf">25.0</span>

<span class="k">let</span> <span class="nv">alsoTenEighty</span> <span class="o">=</span> <span class="n">tenEighty</span>
<span class="n">alsoTenEighty</span><span class="o">.</span><span class="n">frameRate</span> <span class="o">=</span> <span class="mf">30.0</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"The frameRate property of tenEighty is now </span><span class="se">\(</span><span class="n">tenEighty</span><span class="o">.</span><span class="n">frameRate</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "The frameRate property of tenEighty is now 30.0"</span>

<span class="c1">// 因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。</span>
</code></pre>
</div>

<p>注意：tenEighty和alsoTenEighty被声明为常量而不是变量。他们存的是指针，只要指针不改变就ok，指针指向的实例的属性是可以改变的。</p>

<h3 id="section-8">恒等运算符</h3>
<p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>

<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>

<ul>
  <li>等价于（===）  “等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li>
  <li>不等价于（!==）</li>
  <li>以上和=，!=是不同的，注意区分</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="n">tenEighty</span> <span class="o">===</span> <span class="n">alsoTenEighty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"tenEighty and alsoTenEighty refer to the same VideoMode instance."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</span>
</code></pre>
</div>
<h3 id="section-9">指针</h3>

<ul>
  <li>Swift弱化了指针的概念，其实这里的引用类型，就是指针的体现。</li>
  <li>注意Swift中的指针，与C中的指针类似，但并不直接指向某个内存地址，不要求用*来表明创建的是一个引用</li>
</ul>

<h3 id="section-10">选择类还是结构体</h3>

<ul>
  <li>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务</li>
</ul>

<p>构建结构体的条件：</p>
<ul>
  <li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
  <li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
  <li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
  <li>该数据结构不需要去继承另一个既有类型的属性或者行为。
或者：</li>
  <li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。</li>
  <li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li>
  <li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</li>
</ul>

<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>

<h3 id="section-11">字符串、数组、和字典类型的赋值与复制</h3>

<ul>
  <li>
    <p>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
  </li>
  <li>
    <p>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
  </li>
</ul>

<p>注意：
以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p>

<h1 id="properties">属性：Properties</h1>

<ul>
  <li>属性：将值跟特定的类、结构或枚举关联；</li>
  <li>存储属性：存储常量或变量作为实例的一部分。存储属性只能用于类和结构体；</li>
  <li>计算属性：计算一个值。计算属性可以用于类、结构体和枚举；</li>
  <li>类型属性：属性也可以直接作用于类型本身，这种属性称为类型属性；</li>
  <li>属性观察器：监控属性值的变化，以此来触发一个自定义的操作；</li>
  <li>属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</li>
  <li>常量属性在构造过程完成之前必须要有初始值，变量属性则无。</li>
</ul>

<h3 id="stored-properties">储存属性 Stored Properties</h3>

<p>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字var定义），也可以是常量存储属性（用关键字let定义）。</p>

<p>1、在定义属性的时候指定默认值:默认构造器</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ShoppingListItem</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">quantity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">var</span> <span class="nv">purchased</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">item</span> <span class="o">=</span> <span class="kt">ShoppingListItem</span><span class="p">()</span>
</code></pre>
</div>

<p>2、在构造过程中设置或者修改储存属性的值，甚至是常量的储存属性的值：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SurveyQuestion</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">ask</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 修改常量属性的值：</span>
<span class="k">let</span> <span class="nv">beetsQuestion</span> <span class="o">=</span> <span class="kt">SurveyQuestion</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="s">"How about beets?"</span><span class="p">)</span>
<span class="n">beetsQuestion</span><span class="o">.</span><span class="nf">ask</span><span class="p">()</span>
<span class="c1">// 打印 "How about beets?"</span>
<span class="n">beetsQuestion</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">"I also like beets. (But not with cheese.)"</span>
</code></pre>
</div>

<p>3、常量结构体的储存属性：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 属性</span>
<span class="kd">struct</span> <span class="kt">FixedLengthRange</span> <span class="p">{</span>
    <span class="c1">// 变量属性</span>
    <span class="k">var</span> <span class="nv">firstValue</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="c1">// 常量属性</span>
    <span class="k">let</span> <span class="nv">length</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
<span class="c1">// 使用默认构造器：</span>
<span class="k">var</span> <span class="nv">rangeOfThreeItems</span> <span class="o">=</span> <span class="kt">FixedLengthRange</span><span class="p">(</span><span class="nv">firstValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// 修改变量属性</span>
<span class="n">rangeOfThreeItems</span><span class="o">.</span><span class="n">firstValue</span> <span class="o">=</span> <span class="mi">6</span>
<span class="c1">// 不能修改常量属性，error</span>
<span class="n">rangeOfThreeItems</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">// 常量结构体:变量属性不可以修改</span>
<span class="c1">// 如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：</span>
<span class="k">let</span> <span class="nv">hd</span> <span class="o">=</span> <span class="n">rangeOfThreeItems</span>
<span class="n">hd</span><span class="o">.</span><span class="n">firstValue</span> <span class="o">=</span> <span class="mi">2048</span> 
<span class="c1">// this will report an error, even though firstValue is a variable property</span>


</code></pre>
</div>

<p>总结：</p>
<ul>
  <li>结构体是值类型；当器声明为常量的时候，其所有属性，皆是常量，皆不可修改；</li>
  <li>类则不同，他是引用类型，即便是定义为常量，也不影响修改属性；</li>
  <li>变量结构体中的常量属性，不能被修改，变量属性可以修改；</li>
  <li>常量结构体中的常变量属性皆不可修改；</li>
</ul>

<p>4、延时储存属性</p>

<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。</p>

<ul>
  <li>在属性声明前使用lazy来标示一个延迟存储属性；</li>
  <li>必须将延迟存储属性声明成变量（var），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</li>
</ul>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// DataImporter 是一个负责将外部文件中的数据导入的类。这个类的初始化会消耗不少时间。</span>
<span class="kd">class</span> <span class="kt">DataImporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">fileName</span> <span class="o">=</span> <span class="s">"data.txt"</span>
    <span class="c1">// 这里会提供数据导入功能</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">DataManager</span> <span class="p">{</span>
    <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">importer</span> <span class="o">=</span> <span class="kt">DataImporter</span><span class="p">()</span>
    <span class="c1">// data属性初始值是一个空的字符串（String）数组</span>
    <span class="k">var</span> <span class="nv">data</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
    <span class="c1">// 这里会提供数据管理功能</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">manager</span> <span class="o">=</span> <span class="kt">DataManager</span><span class="p">()</span>
<span class="n">manager</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Some data"</span><span class="p">)</span>
<span class="n">manager</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Some more data"</span><span class="p">)</span>
<span class="c1">// the DataImporter instance for the importer property has not yet been created</span>

<span class="c1">// 只有使用的时候才会创建</span>
<span class="nf">print</span><span class="p">(</span><span class="n">manager</span><span class="o">.</span><span class="n">importer</span><span class="o">.</span><span class="n">fileName</span><span class="p">)</span>
<span class="c1">// Prints "data.txt"</span>
</code></pre>
</div>

<p>注意：如果一个被标记为lazy的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>

<p>5、存储属性和实例变量</p>

<p>OC为类实例存储值和引用提供两种方法，除了属性之外，还可以使用实例变量作为属性值的后端存储。</p>

<p>Swift编程语言中把这些理论统一用属性来实现。Swift中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>

<h3 id="computed-properties">计算属性 Computed Properties</h3>

<p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个getter 和一个可选的setter，来间接获取和设置其他属性或变量的值。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// Point 封装了一个 (x, y) 的坐标</span>
<span class="kd">struct</span> <span class="kt">Point</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>

<span class="c1">// Size 封装了一个 width 和一个 height</span>
<span class="kd">struct</span> <span class="kt">Size</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">}</span>

<span class="c1">// Rect 表示一个有原点和尺寸的矩形</span>
<span class="kd">struct</span> <span class="kt">Rect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">origin</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">()</span>
<span class="c1">// 一个矩形的中心点可以从原点（origin）和大小（size）算出，所以不需要将它以显式声明的 Point来保存</span>
    <span class="k">var</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">Point</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">square</span> <span class="o">=</span> <span class="kt">Rect</span><span class="p">(</span><span class="nv">origin</span><span class="p">:</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span>
                  <span class="nv">size</span><span class="p">:</span> <span class="kt">Size</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="k">let</span> <span class="nv">initialSquareCenter</span> <span class="o">=</span> <span class="n">square</span><span class="o">.</span><span class="n">center</span>
<span class="n">square</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"square.origin is now at (</span><span class="se">\(</span><span class="n">square</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">square</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="se">)</span><span class="s">)"</span><span class="p">)</span>
<span class="c1">// Prints "square.origin is now at (10.0, 10.0)"</span>
</code></pre>
</div>

<p><img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="" /></p>

<p>2、简化setter声明
如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。下面是使用了简化 setter 声明的 Rect 结构体代码：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">AlternativeRect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">origin</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">Point</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>3、只读属性</p>

<p>只有getter没有setter的计算属性就是只读计算属性。</p>

<ul>
  <li>只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</li>
  <li>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。</li>
  <li>let关键字只用来声明常量属性，表示初始化后再也无法修改的值。</li>
</ul>

<p>只读计算属性的声明可以去掉 get 关键字和花括号：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Cuboid</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">volume</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">fourByFiveByTwo</span> <span class="o">=</span> <span class="kt">Cuboid</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nv">depth</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"the volume of fourByFiveByTwo is </span><span class="se">\(</span><span class="n">fourByFiveByTwo</span><span class="o">.</span><span class="n">volume</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "the volume of fourByFiveByTwo is 40.0"</span>
<span class="cm">/*
结构体还有一个名为 volume 的只读计算属性用来返回立方体的体积。为 volume 提供 setter 毫无意义，因为无法确定如何修改 width、height 和 depth 三者的值来匹配新的 volume。然而，Cuboid 提供一个只读计算属性来让外部用户直接获取体积是很有用的。*/</span>
</code></pre>
</div>

<h3 id="property-observers">属性观察器 Property Observers</h3>

<p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>

<ul>
  <li>可以为除了延迟存储属性之外的其他存储属性添加属性观察器;</li>
  <li>也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器</li>
  <li>你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化</li>
</ul>

<p>可以为属性添加如下的一个或全部观察器：</p>
<ul>
  <li>
    <p>willSet 在新的值被设置之前调用:willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。</p>
  </li>
  <li>
    <p>didSet 在新的值被设置之后立即调用:didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>
  </li>
  <li>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器</li>
  <li>在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用</li>
  <li>默认值 oldValue 表示旧值的参数名。</li>
</ul>

<p>案例：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">StepCounter</span> <span class="p">{</span>
<span class="c1">// 定义了一个 Int 类型的属性 totalSteps，它是一个存储属性，包含 willSet 和 didSet 观察器。</span>
    <span class="k">var</span> <span class="nv">totalSteps</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">willSet</span><span class="p">(</span><span class="n">newTotalSteps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"About to set totalSteps to </span><span class="se">\(</span><span class="n">newTotalSteps</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">totalSteps</span> <span class="o">&gt;</span> <span class="n">oldValue</span>  <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"Added </span><span class="se">\(</span><span class="n">totalSteps</span> <span class="o">-</span> <span class="n">oldValue</span><span class="se">)</span><span class="s"> steps"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">stepCounter</span> <span class="o">=</span> <span class="kt">StepCounter</span><span class="p">()</span>
<span class="c1">// 当 totalSteps 被设置新值的时候，它的 willSet 和 didSet 观察器都会被调用，即使新值和当前值完全相同时也会被调用。</span>

<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">200</span>
<span class="c1">// About to set totalSteps to 200</span>
<span class="c1">// Added 200 steps</span>
<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">360</span>
<span class="c1">// About to set totalSteps to 360</span>
<span class="c1">// Added 160 steps</span>
<span class="n">stepCounter</span><span class="o">.</span><span class="n">totalSteps</span> <span class="o">=</span> <span class="mi">896</span>
<span class="c1">// About to set totalSteps to 896</span>
<span class="c1">// Added 536 steps</span>
</code></pre>
</div>

<p>注意：如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>

<h3 id="global-and-local-variables">全局变量和局部变量 Global and Local Variables</h3>

<p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<ul>
  <li>全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</li>
  <li>在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</li>
  <li>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，</li>
  <li>全局的常量或变量不需要标记lazy修饰符。</li>
  <li>局部范围的常量或变量从不延迟计算。</li>
</ul>

<h3 id="type-properties">类型属性 Type Properties</h3>

<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>

<ul>
  <li>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</li>
  <li>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。</li>
  <li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</li>
  <li>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</li>
  <li>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</li>
</ul>

<p>1、类型属性语法</p>

<p>在C或OC中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>

<p>使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 下面的例子演示了存储型和计算型类型属性的语法：</span>
<span class="kd">struct</span> <span class="kt">SomeStructure</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="kt">SomeEnumeration</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">6</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">SomeClass</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Some value."</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">27</span>
    <span class="p">}</span>
    <span class="kd">class</span> <span class="k">var</span> <span class="nv">overrideableComputedTypeProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">107</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>注意：
例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。</p>

<p>2、获取和设置类型属性的值</p>

<p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "Some value."</span>
<span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span> <span class="o">=</span> <span class="s">"Another value."</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeStructure</span><span class="o">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "Another value."</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeEnumeration</span><span class="o">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "6"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">SomeClass</span><span class="o">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// Prints "27"</span>
</code></pre>
</div>

<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有 0 到 10 之间的整数音量。下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是 0，没有一个灯会亮；当声道的音量是 10，所有灯点亮。本图中，左声道的音量是 9，右声道的音量是 7
<img src="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="" /></p>

<p>上面所描述的声道模型使用 AudioChannel 结构体的实例来表示：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">AudioChannel</span> <span class="p">{</span>
    <span class="c1">// 存储型类型属性：音量的最大上限阈值</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">thresholdLevel</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="c1">// 存储型类型属性：表示所有 AudioChannel 实例的最大音量，初始值是0</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">maxInputLevelForAllChannels</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 存储型实例属,包含 didSet 属性观察器来检查每次设置后的属性值。</span>
    <span class="k">var</span> <span class="nv">currentLevel</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">thresholdLevel</span> <span class="p">{</span>
                <span class="c1">// 将当前音量限制在阀值之内</span>
                <span class="n">currentLevel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">thresholdLevel</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="p">{</span>
                <span class="c1">// 存储当前音量作为新的最大输入音量</span>
                <span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="o">=</span> <span class="n">currentLevel</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可以使用结构体 AudioChannel 创建两个声道 leftChannel 和rightChannel，用以表示立体声系统的音量：</span>
<span class="k">var</span> <span class="nv">leftChannel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">rightChannel</span> <span class="o">=</span> <span class="kt">AudioChannel</span><span class="p">()</span>

<span class="c1">// 如果将左声道的 currentLevel 设置成 7，类型属性 maxInputLevelForAllChannels 也会更新成 7：</span>
<span class="n">leftChannel</span><span class="o">.</span><span class="n">currentLevel</span> <span class="o">=</span> <span class="mi">7</span>
<span class="nf">print</span><span class="p">(</span><span class="n">leftChannel</span><span class="o">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// Prints "7"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// Prints "7"</span>

<span class="c1">// 如果试图将右声道的 currentLevel 设置成 11，它会被修正到最大值 10，同时 maxInputLevelForAllChannels 的值也会更新到 10：</span>
<span class="n">rightChannel</span><span class="o">.</span><span class="n">currentLevel</span> <span class="o">=</span> <span class="mi">11</span>
<span class="nf">print</span><span class="p">(</span><span class="n">rightChannel</span><span class="o">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// Prints "10"</span>
<span class="nf">print</span><span class="p">(</span><span class="kt">AudioChannel</span><span class="o">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// Prints "10"</span>
</code></pre>
</div>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/07/swift_VII_Closures/">Swift3.0_VII_闭包</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-07
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前言</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">闭包表达式</a>        <ul>
          <li><a href="#section-2" id="markdown-toc-section-2">闭包表达式语法</a></li>
          <li><a href="#sorted" id="markdown-toc-sorted">sorted函数</a></li>
        </ul>
      </li>
      <li><a href="#trailing-closures" id="markdown-toc-trailing-closures">尾随闭包(Trailing Closures)</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">前言</h2>

<p><strong>闭包：独立的代码块，可以传递及引用。</strong></p>

<ul>
  <li>闭包可以捕获和存储其所在上下文中任意常量和变量的引用；</li>
  <li>Swift会管理捕获过程中涉及到的所有内存管理；</li>
</ul>

<p>闭包的形式：</p>
<ul>
  <li>全局函数都是闭包，特点是有函数名但没有捕获任何值。</li>
  <li>嵌套函数都是闭包，特点是有函数名，并且可以在它封闭的函数中捕获值。</li>
  <li>闭包表达式都是闭包，特点是没有函数名，可以使用轻量的语法在它所围绕的上下文中捕获值。</li>
</ul>

<p>语法优化：</p>
<ul>
  <li>根据上下文推理参数及返回值类型</li>
  <li>隐式返回单表达式闭包，即单表达式闭包可以省略 return 关键字</li>
  <li>参数名称缩写</li>
  <li>尾随闭包语法</li>
</ul>

<h3 id="section-1">闭包表达式</h3>

<p>闭包表达式是一种编写内联闭包的方式，它简洁、紧凑。闭包表达式提供了数种语义优化，为的是以最简单的形式编程而不需要大量的声明或意图。以下以同一个sort函数进行几次改进，每次函数都更加简洁，以此说明闭包表达式的优化</p>

<h5 id="section-2">闭包表达式语法</h5>
<p>闭合表达式语法具有以下一般构造形式：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="p">{</span> <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="n">type</span> <span class="k">in</span>
    <span class="n">statements</span>
<span class="p">}</span>
</code></pre>
</div>
<p>闭包表达式语法可以使用常量参数、变量参数和 inout 类型作为参数，但皆不可提供默认值。</p>

<h5 id="sorted">sorted函数</h5>

<p>Swift的标准函数库提供了一个名为sort的函数,他用于输出类型排序的闭包函数，给已知类型的数组数据的值排序:</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">by</span> <span class="nv">areInIncreasingOrder</span><span class="p">:</span> <span class="p">(</span><span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>  <span class="o">-&gt;</span>  <span class="p">[</span><span class="kt">Element</span><span class="p">]</span>

<span class="nv">使用</span><span class="p">:</span>
 <span class="k">let</span> <span class="nv">students</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Kofi"</span><span class="p">,</span> <span class="s">"Abena"</span><span class="p">,</span> <span class="s">"Peter"</span><span class="p">,</span> <span class="s">"Kweku"</span><span class="p">,</span> <span class="s">"Akosua"</span><span class="p">]</span>
 <span class="k">let</span> <span class="nv">descendingStudents</span> <span class="o">=</span> <span class="n">students</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
 <span class="nf">print</span><span class="p">(</span><span class="n">descendingStudents</span><span class="p">)</span> <span class="c1">//1 Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"</span>
 <span class="nf">print</span><span class="p">(</span><span class="n">students</span><span class="o">.</span><span class="nf">sorted</span><span class="p">())</span> <span class="c1">//2 Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"</span>
 <span class="nf">print</span><span class="p">(</span><span class="n">students</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&lt;</span><span class="p">))</span> <span class="c1">//3  Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"</span>

</code></pre>
</div>

<p>1、先看一个排序的例子：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Chris"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">,</span> <span class="s">"Ewa"</span><span class="p">,</span> <span class="s">"Barry"</span><span class="p">,</span> <span class="s">"Daniella"</span><span class="p">]</span>
<span class="kd">func</span> <span class="nf">backward</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">backward</span><span class="p">)</span>
<span class="c1">// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span>

</code></pre>
</div>

<p>2、闭包表达式来改写上边的例子：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversed</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
<span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">})</span>
</code></pre>
</div>

<p>3、可以用一行来表达：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</code></pre>
</div>

<p>4、Swift可以根据上下文推断类型，因此可以省略String:</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</code></pre>
</div>

<p>5、单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</code></pre>
</div>

<p>6、参数名简写:</p>

<ul>
  <li>Swift 自动为内联闭包提供了参数名称简写功能，</li>
  <li>可以直接通过 $0,$1,$2等名字来引用闭包的参数值</li>
  <li>关键字:in、return 可以省略,此时闭包表达式完全由闭包函数体构成</li>
  <li>下边例子;$0和$1表示闭包中第一个和第二个String类型的参数。
    <div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span> <span class="p">)</span>
</code></pre>
    </div>
  </li>
</ul>

<p>7、运算符函数：
Swift为String类型定义了大于算子（&gt;），通过大于算子简写如下</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
</code></pre>
</div>

<p>8、Trailing 闭包</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</code></pre>
</div>

<p>总结，如下：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Chris"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">,</span> <span class="s">"Ewa"</span><span class="p">,</span> <span class="s">"Barry"</span><span class="p">,</span> <span class="s">"Daniella"</span><span class="p">]</span>
<span class="kd">func</span> <span class="nf">backward</span><span class="p">(</span><span class="n">_</span> <span class="nv">s1</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">s2</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">ss1</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">backward</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">ss2</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{(</span><span class="nv">s1</span><span class="p">:</span><span class="kt">String</span><span class="p">,</span><span class="nv">s2</span><span class="p">:</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span><span class="o">&gt;</span><span class="n">s2</span> <span class="p">})</span>
<span class="k">var</span> <span class="nv">ss3</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
<span class="k">var</span> <span class="nv">ss4</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
<span class="k">var</span> <span class="nv">ss5</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span> <span class="p">)</span>
<span class="k">var</span> <span class="nv">ss6</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">ss7</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
<span class="n">以上</span> <span class="n">ss1到ss7结果相同</span><span class="err">，</span><span class="n">都是</span> <span class="p">[</span><span class="s">"Ewa"</span><span class="p">,</span> <span class="s">"Daniella"</span><span class="p">,</span> <span class="s">"Chris"</span><span class="p">,</span> <span class="s">"Barry"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">]</span>
</code></pre>
</div>

<h3 id="trailing-closures">尾随闭包(Trailing Closures)</h3>

<p>如果需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用trailing闭包来替代。Trailing 闭包是一个书写在函数括号之外(之后)的闭包表达式，函数支持将其作为最后一个参数调用。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunctionThatTakesAClosure</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// function body goes here</span>
<span class="p">}</span>
<span class="c1">// Here's how you call this function without using a trailing closure:</span>
<span class="nf">someFunctionThatTakesAClosure</span><span class="p">(</span><span class="nv">closure</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// closure's body goes here</span>
<span class="p">})</span>
<span class="c1">// Here's how you call this function with a trailing closure instead:</span>
<span class="nf">someFunctionThatTakesAClosure</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// trailing closure's body goes here</span>
<span class="p">}</span>
</code></pre>
</div>

<p>上述的sort函数可以改写为：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="nf">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</code></pre>
</div>

<p>如果一个封闭表达式是作为函数或方法唯一的参数,可以忽略()</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">reversedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</code></pre>
</div>

<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。</p>

<p>举例来说，Swift的Array类型有一个map方法，其获取一个闭包表达式作为其唯一参数。 数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。 具体的映射方式和返回值类型由闭包来指定。</p>

<p>当提供给数组闭包函数后，map方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值，
下例介绍了如何在map方法中使用尾随闭包将Int类型数组[16,58,510]转换为包含对应String类型的数组[“OneSix”, “FiveEight”, “FiveOneZero”]:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">digitNames</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s">"Zero"</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">"One"</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">"Two"</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">"Three"</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">"Four"</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">:</span> <span class="s">"Five"</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s">"Six"</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="s">"Seven"</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="s">"Eight"</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="s">"Nine"</span>
<span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">510</span><span class="p">]</span>
</code></pre>
</div>

<p>通过调用numbers.map来调用映射后的String数组
使用如下：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">strings</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
    <span class="k">var</span> <span class="nv">number</span> <span class="o">=</span> <span class="n">number</span>
    <span class="k">var</span> <span class="nv">output</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">repeat</span> <span class="p">{</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">digitNames</span><span class="p">[</span><span class="n">number</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span><span class="o">!</span> <span class="o">+</span> <span class="n">output</span>
        <span class="n">number</span> <span class="o">/=</span> <span class="mi">10</span>
    <span class="p">}</span> <span class="k">while</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">output</span>
<span class="p">}</span>
<span class="c1">// strings is inferred to be of type [String]</span>
<span class="c1">// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span>
</code></pre>
</div>
<p>注意： 字典digitNames下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key不存在也不会查找失败。 在上例中，它保证了number % 10可以总是作为一个 digitNames字典的有效下标key。 因此叹号可以用于解析存储在可选下标项中的String类型值。</p>


                </div>
                <div class="read-all">
                    <a  href="/2016/12/07/swift_VII_Closures/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2016/12/05/swift_VI_Functions/">Swift3.0_VI_函数</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2016-12-05
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Swift3.0" title="Category: Swift3.0" rel="category">Swift3.0</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Swift3.0" title="Tag: Swift3.0" rel="tag">Swift3.0</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#defining-and-calling-functions" id="markdown-toc-defining-and-calling-functions">Defining and Calling Functions：定义和调用</a></li>
  <li><a href="#function-parameters-and-return-values" id="markdown-toc-function-parameters-and-return-values">Function Parameters and Return Values:功能参数和返回值</a></li>
  <li><a href="#function-argument-labels-and-parameter-names" id="markdown-toc-function-argument-labels-and-parameter-names">Function Argument Labels and Parameter Names:参数标签和参数名称</a></li>
  <li><a href="#function-types" id="markdown-toc-function-types">Function Types：函数功能</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">功能类型作为参数类型</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">功能类型作为返回类型</a></li>
    </ul>
  </li>
  <li><a href="#nested-functions" id="markdown-toc-nested-functions">Nested Functions：嵌套函数</a></li>
</ul>

<h3 id="defining-and-calling-functions">Defining and Calling Functions：定义和调用</h3>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 关键字func  函数名greet  参数名:参数类型String  连接返回值:-&gt;  返回值类型String</span>
       <span class="kd">func</span>    <span class="nf">greet</span>     <span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>      <span class="o">-&gt;</span>          <span class="kt">String</span>     <span class="p">{</span>
    <span class="k">let</span> <span class="nv">greeting</span> <span class="o">=</span> <span class="s">"Hello, "</span> <span class="o">+</span> <span class="n">person</span> <span class="o">+</span> <span class="s">"!"</span>
    <span class="k">return</span> <span class="n">greeting</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Anna"</span><span class="p">))</span>
<span class="c1">// Prints "Hello, Anna!"</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Brian"</span><span class="p">))</span>
<span class="c1">// Prints "Hello, Brian!"</span>


<span class="kd">func</span> <span class="nf">greetAgain</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello again, "</span> <span class="o">+</span> <span class="n">person</span> <span class="o">+</span> <span class="s">"!"</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">greetAgain</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Anna"</span><span class="p">))</span>
<span class="c1">// Prints "Hello again, Anna!"</span>
</code></pre>
</div>

<h3 id="function-parameters-and-return-values">Function Parameters and Return Values:功能参数和返回值</h3>

<p><strong>不带参数的函数：</strong></p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sayHelloWorld</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"hello, world"</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">sayHelloWorld</span><span class="p">())</span>
<span class="c1">// Prints "hello, world"</span>
</code></pre>
</div>

<p><strong>多参数：</strong></p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">alreadyGreeted</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">alreadyGreeted</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">greetAgain</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="n">person</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="n">person</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Tim"</span><span class="p">,</span> <span class="nv">alreadyGreeted</span><span class="p">:</span> <span class="kc">true</span><span class="p">))</span>
<span class="c1">// Prints "Hello again, Tim!"</span>
</code></pre>
</div>

<p><strong>无返回值：</strong></p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, </span><span class="se">\(</span><span class="n">person</span><span class="se">)</span><span class="s">!"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Dave"</span><span class="p">)</span>
<span class="c1">// Prints "Hello, Dave!"</span>
</code></pre>
</div>

<p><strong>调用时忽略返回值：</strong></p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">printAndCount</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">printWithoutCounting</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="nf">printAndCount</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">string</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">printAndCount</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"hello, world"</span><span class="p">)</span>
<span class="c1">// prints "hello, world" and returns a value of 12</span>
<span class="nf">printWithoutCounting</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"hello, world"</span><span class="p">)</span>
<span class="c1">// prints "hello, world" but does not return a value</span>
</code></pre>
</div>

<p><strong>返回元组</strong></p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nv">min</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">currentMin</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">currentMax</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="o">..&lt;</span><span class="n">array</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">currentMin</span> <span class="p">{</span>
            <span class="n">currentMin</span> <span class="o">=</span> <span class="n">value</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">currentMax</span> <span class="p">{</span>
            <span class="n">currentMax</span> <span class="o">=</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">return</span> <span class="p">(</span><span class="n">currentMin</span><span class="p">,</span> <span class="n">currentMax</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">bounds</span> <span class="o">=</span> <span class="nf">minMax</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"min is </span><span class="se">\(</span><span class="n">bounds</span><span class="o">.</span><span class="n">min</span><span class="se">)</span><span class="s"> and max is </span><span class="se">\(</span><span class="n">bounds</span><span class="o">.</span><span class="n">max</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
</code></pre>
</div>

<p><strong>返回可选的元组类型</strong></p>

<p>(Int, Int)? 与(Int?, Int?)不同，前者是可选的元组，后者是元组内元素可选的。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nv">min</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)?</span> <span class="p">{</span>
    <span class="c1">// 如果array为nil，后边会运行时错误，所以要判断：</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">currentMin</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">currentMax</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="o">..&lt;</span><span class="n">array</span><span class="o">.</span><span class="n">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">currentMin</span> <span class="p">{</span>
            <span class="n">currentMin</span> <span class="o">=</span> <span class="n">value</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">currentMax</span> <span class="p">{</span>
            <span class="n">currentMax</span> <span class="o">=</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">return</span> <span class="p">(</span><span class="n">currentMin</span><span class="p">,</span> <span class="n">currentMax</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 此时bounds是可选元组，通过可选绑定来取值</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">bounds</span> <span class="o">=</span> <span class="nf">minMax</span><span class="p">(</span><span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"min is </span><span class="se">\(</span><span class="n">bounds</span><span class="o">.</span><span class="n">min</span><span class="se">)</span><span class="s"> and max is </span><span class="se">\(</span><span class="n">bounds</span><span class="o">.</span><span class="n">max</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "min is -6 and max is 109"</span>
</code></pre>
</div>

<h3 id="function-argument-labels-and-parameter-names">Function Argument Labels and Parameter Names:参数标签和参数名称</h3>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="nv">firstParameterName</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">secondParameterName</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// In the function body, firstParameterName and secondParameterName</span>
    <span class="c1">// refer to the argument values for the first and second parameters.</span>
<span class="p">}</span>
<span class="nf">someFunction</span><span class="p">(</span><span class="nv">firstParameterName</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">secondParameterName</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>

<p><strong>指定参数标签</strong></p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">from</span> <span class="nv">hometown</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">person</span><span class="se">)</span><span class="s">!  Glad you could visit from </span><span class="se">\(</span><span class="n">hometown</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Bill"</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="s">"Cupertino"</span><span class="p">))</span>
<span class="c1">// Prints "Hello Bill!  Glad you could visit from Cupertino."</span>
</code></pre>
</div>

<p><strong>省略参数标签</strong>
加下划线即可：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">firstParameterName</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">secondParameterName</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// In the function body, firstParameterName and secondParameterName</span>
    <span class="c1">// refer to the argument values for the first and second parameters.</span>
<span class="p">}</span>
<span class="nf">someFunction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">secondParameterName</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>

<p><strong>默认参数值</strong></p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="nv">parameterWithoutDefault</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">parameterWithDefault</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If you omit the second argument when calling this function, then</span>
    <span class="c1">// the value of parameterWithDefault is 12 inside the function body.</span>
<span class="p">}</span>
<span class="nf">someFunction</span><span class="p">(</span><span class="nv">parameterWithoutDefault</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nv">parameterWithDefault</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// parameterWithDefault is 6</span>
<span class="nf">someFunction</span><span class="p">(</span><span class="nv">parameterWithoutDefault</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// parameterWithDefault is 12</span>
</code></pre>
</div>

<p><strong>可变参数</strong></p>

<p>注意：函数最多只有一个可变参数。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">arithmeticMean</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="kt">Double</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">total</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="kt">Double</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">arithmeticMean</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// returns 3.0, which is the arithmetic mean of these five numbers</span>
<span class="nf">arithmeticMean</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.25</span><span class="p">,</span> <span class="mf">18.75</span><span class="p">)</span>
<span class="c1">// returns 10.0, which is the arithmetic mean of these three numbers</span>
</code></pre>
</div>

<p><strong>IN-OUT参数</strong></p>

<ul>
  <li>输入输出参数：在参数定义前加inout 关键字来定义。</li>
  <li>一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。</li>
  <li>只能将变量作为输入输出参数。当传入的参数作为输入输出参数时，需要在参数前加&amp;符，表示这个值可以被函数修改。</li>
</ul>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">someInt</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">var</span> <span class="nv">anotherInt</span> <span class="o">=</span> <span class="mi">107</span>
<span class="nf">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"someInt is now </span><span class="se">\(</span><span class="n">someInt</span><span class="se">)</span><span class="s">, and anotherInt is now </span><span class="se">\(</span><span class="n">anotherInt</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "someInt is now 107, and anotherInt is now 3"</span>
</code></pre>
</div>

<h3 id="function-types">Function Types：函数功能</h3>

<p>这两个函数的类型是 (Int, Int) -&gt; Int，可以读作“这个函数类型，它有两个In 型的参数并返回一个 Int型的值。”。</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">addTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">multiplyTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre>
</div>

<p>如下代码可以解读为：“定义一个叫做mathFunction的变量，类型是‘一个有两个Int型的参数并返回一个 Int型的值的函数’，并让这个新变量指向addTwoInts函数”。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">addTwoInts</span>
</code></pre>
</div>

<p>然后可调用：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"Result: </span><span class="se">\(</span><span class="nf">mathFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "Result: 5"</span>
</code></pre>
</div>

<p>具有相同类型的变量可以指向不同的功能：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">mathFunction</span> <span class="o">=</span> <span class="n">multiplyTwoInts</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Result: </span><span class="se">\(</span><span class="nf">mathFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// Prints "Result: 6"</span>
</code></pre>
</div>

<p>和其他类型一样，可以指向常量或者变量：</p>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">anotherMathFunction</span> <span class="o">=</span> <span class="n">addTwoInts</span>
<span class="c1">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span>
</code></pre>
</div>

<h5 id="section">功能类型作为参数类型</h5>

<p>可以用(Int, Int) -&gt; Int这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现交由给函数的调用者。</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">multiplyTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>

<span class="n">mathFunction</span> <span class="o">=</span> <span class="n">multiplyTwoInts</span>

<span class="kd">func</span> <span class="nf">addTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printMathResult</span><span class="p">(</span><span class="n">_</span> <span class="nv">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Result: </span><span class="se">\(</span><span class="nf">mathFunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">printMathResult</span><span class="p">(</span><span class="n">addTwoInts</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// Prints "Result: 8"</span>
</code></pre>
</div>

<p>这个例子定义了printMathResult函数，它有三个参数：第一个参数 mathFunction，类型是(Int, Int) -&gt; Int，可以传入任何这种类型的函数；第二个和第三个参数 a 和 b，它们的类型都是 Int，<strong>这两个值作为已给的函数的输入值</strong></p>

<h5 id="section-1">功能类型作为返回类型</h5>
<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="c1">// 基础移动函数</span>
<span class="kd">func</span> <span class="nf">stepForward</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">stepBackward</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 函数：chooseStepFunction(backward:)，它的返回类型为(Int) -&gt; Int</span>
<span class="kd">func</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="nv">backward</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">backward</span> <span class="p">?</span> <span class="nv">stepBackward</span> <span class="p">:</span> <span class="n">stepForward</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">currentValue</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// 一个指向函数的常量 moveNearerToZero</span>
<span class="k">let</span> <span class="nv">moveNearerToZero</span> <span class="o">=</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="nv">backward</span><span class="p">:</span> <span class="n">currentValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Counting to zero:"</span><span class="p">)</span>

<span class="k">while</span> <span class="n">currentValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">currentValue</span><span class="se">)</span><span class="s">... "</span><span class="p">)</span>
    <span class="n">currentValue</span> <span class="o">=</span> <span class="nf">moveNearerToZero</span><span class="p">(</span><span class="n">currentValue</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"zero!"</span><span class="p">)</span>
<span class="c1">// 3...</span>
<span class="c1">// 2...</span>
<span class="c1">// 1...</span>
<span class="c1">// zero!</span>
</code></pre>
</div>

<h3 id="nested-functions">Nested Functions：嵌套函数</h3>

<p>重写上边的归零函数：</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="nv">backward</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">stepForward</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">stepBackward</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">backward</span> <span class="p">?</span> <span class="nv">stepBackward</span> <span class="p">:</span> <span class="n">stepForward</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">currentValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
<span class="k">let</span> <span class="nv">moveNearerToZero</span> <span class="o">=</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="nv">backward</span><span class="p">:</span> <span class="n">currentValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// moveNearerToZero now refers to the nested stepForward() function</span>
<span class="k">while</span> <span class="n">currentValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">currentValue</span><span class="se">)</span><span class="s">... "</span><span class="p">)</span>
    <span class="n">currentValue</span> <span class="o">=</span> <span class="nf">moveNearerToZero</span><span class="p">(</span><span class="n">currentValue</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"zero!"</span><span class="p">)</span>
<span class="c1">// -4...</span>
<span class="c1">// -3...</span>
<span class="c1">// -2...</span>
<span class="c1">// -1...</span>
<span class="c1">// zero!</span>
</code></pre>
</div>

                </div>
                <div class="read-all">
                    <a  href="/2016/12/05/swift_VI_Functions/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <span class="previous disable"><i class="fa fa-angle-double-left"></i></span>
            <span class="previous disable"><i class="fa fa-angle-left"></i></span>
          
          <span class="page_number ">1/6</span>
          
            <a href="/page2" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page6" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    最新文章
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/01/18/SDiffuseMenu/">Swift 版 AwesomeMenu 的改写之旅:SDiffuseMenu</a></li>
                    
                        <li><a href="/2016/12/11/swift_X_Initialization_Deinitialization/">Swift3.0_X_构造过程和析构过程 </a></li>
                    
                        <li><a href="/2016/12/10/swift_IX_Methods_Subscripts_Inheritance/">Swift3.0_IX_方法、下标和继承 </a></li>
                    
                        <li><a href="/2016/12/08/swift_VIII_Enumerations_Classes_Structures_Properties/">Swift3.0_VIII_枚举、类、结构体、属性</a></li>
                    
                        <li><a href="/2016/12/07/swift_VII_Closures/">Swift3.0_VII_闭包</a></li>
                    
                        <li><a href="/2016/12/05/swift_VI_Functions/">Swift3.0_VI_函数</a></li>
                    
                        <li><a href="/2016/12/03/swift_V_Control-Flow/">Swift3.0_V_控制流</a></li>
                    
                        <li><a href="/2016/12/01/swift_IV_Collection-Types/">Swift3.0_IV_集合</a></li>
                    
                        <li><a href="/2016/11/26/swift_III_Strings-and-Characters/">Swift_III_字符(串)</a></li>
                    
                        <li><a href="/2016/11/22/swift_II_Basic-Operators/">Swift_II_基本运算符</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    分类
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#apache" class="categories-list-item" cate="apache">
                            <span class="name">
                                apache
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#WKWebView" class="categories-list-item" cate="WKWebView">
                            <span class="name">
                                WKWebView
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IOS逆向" class="categories-list-item" cate="IOS逆向">
                            <span class="name">
                                IOS逆向
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#block" class="categories-list-item" cate="block">
                            <span class="name">
                                block
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#NSURLProtocol" class="categories-list-item" cate="NSURLProtocol">
                            <span class="name">
                                NSURLProtocol
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#缓存" class="categories-list-item" cate="缓存">
                            <span class="name">
                                缓存
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#NSURLCache" class="categories-list-item" cate="NSURLCache">
                            <span class="name">
                                NSURLCache
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#SecureCRT" class="categories-list-item" cate="SecureCRT">
                            <span class="name">
                                SecureCRT
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#博客" class="categories-list-item" cate="博客">
                            <span class="name">
                                博客
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#jekyll" class="categories-list-item" cate="jekyll">
                            <span class="name">
                                jekyll
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#OS_X" class="categories-list-item" cate="OS_X">
                            <span class="name">
                                OS_X
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Sublime" class="categories-list-item" cate="Sublime">
                            <span class="name">
                                Sublime
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#iOS逆向" class="categories-list-item" cate="iOS逆向">
                            <span class="name">
                                iOS逆向
                            </span>
                            <span class="badge">7</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IOS基础" class="categories-list-item" cate="IOS基础">
                            <span class="name">
                                IOS基础
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#python" class="categories-list-item" cate="python">
                            <span class="name">
                                python
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Swift" class="categories-list-item" cate="Swift">
                            <span class="name">
                                Swift
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Swift3.0" class="categories-list-item" cate="Swift3.0">
                            <span class="name">
                                Swift3.0
                            </span>
                            <span class="badge">8</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                      
                      
                      
                      
                      
                      <a href="/tag/#apache" style="font-size: 9pt; color: #999;">apache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#WKWebView、Native与JS、缓存、NSURLProtocol" style="font-size: 9pt; color: #999;">WKWebView、Native与JS、缓存、NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Charles" style="font-size: 9pt; color: #999;">Charles</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Reveal" style="font-size: 9pt; color: #999;">Reveal</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOSOpenDev" style="font-size: 9pt; color: #999;">iOSOpenDev</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#block" style="font-size: 9pt; color: #999;">block</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLProtocol" style="font-size: 9pt; color: #999;">NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#缓存" style="font-size: 10.5pt; color: #888;">缓存</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLCache" style="font-size: 9pt; color: #999;">NSURLCache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#SecureCRT" style="font-size: 9pt; color: #999;">SecureCRT</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#博客" style="font-size: 9pt; color: #999;">博客</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#jekyll" style="font-size: 9pt; color: #999;">jekyll</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#sublime" style="font-size: 9pt; color: #999;">sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#环境变量" style="font-size: 9pt; color: #999;">环境变量</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Sublime" style="font-size: 10.5pt; color: #888;">Sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向" style="font-size: 9pt; color: #999;">iOS逆向</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#class_dump" style="font-size: 9pt; color: #999;">class_dump</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Theos" style="font-size: 10.5pt; color: #888;">Theos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Logos" style="font-size: 9pt; color: #999;">Logos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS代码规范" style="font-size: 9pt; color: #999;">IOS代码规范</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS基础" style="font-size: 9pt; color: #999;">IOS基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IDA、iFunBox、dyld_decache" style="font-size: 9pt; color: #999;">IDA、iFunBox、dyld_decache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向工具集" style="font-size: 9pt; color: #999;">iOS逆向工具集</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS逆向理论基础" style="font-size: 9pt; color: #999;">iOS逆向理论基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#爬基金数据" style="font-size: 9pt; color: #999;">爬基金数据</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#脚本" style="font-size: 9pt; color: #999;">脚本</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Swift" style="font-size: 11.5pt; color: #666;">Swift</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Swift3.0" style="font-size: 18pt; color: #000;">Swift3.0</a>
                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             3行代码的技术博客 
        </p>
        <p class="contact">
            Contact me at:  
            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>   -->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>-->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>        -->


        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
        
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>

          <!--   <span>
                Theme designed by <a href="https://github.com/mythkiven">MyKiven</a>.
            </span> -->

        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
  </body>

</html>
