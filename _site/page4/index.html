<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>3行代码</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="/css/fontawesome/css/font-awesome.min.css ">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/page4/">
    <link rel="alternate" type="application/rss+xml" title="3行代码" href="http://localhost:4000/feed.xml ">


<script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
     var hm = document.createElement("script");
     hm.src = "//hm.baidu.com/hm.js?d9432112fb859bf7276f8399641fb0c5";
     var s = document.getElementsByTagName("script")[0];
     s.parentNode.insertBefore(hm, s);
     })();
    </script>




    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-85978943-1', 'auto');
      ga('send', 'pageview');

    </script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">3行代码</a>
        <small>技术博客</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>


                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>Welcome to 3code.info!</h1>
        <small>记录生活</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/10/15/NSURLProtocol/">NSURLProtocol使用报告</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-10-15
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#NSURLProtocol" title="Category: NSURLProtocol" rel="category">NSURLProtocol</a>&nbsp;
    
        <a href="/category/#缓存~~~" title="Category: 缓存~~~" rel="category">缓存~~~</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#NSURLProtocol" title="Tag: NSURLProtocol" rel="tag">NSURLProtocol</a>&nbsp;
    
        <a href="/tag/#缓存" title="Tag: 缓存" rel="tag">缓存</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1、基本使用</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、注册</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">2、实现方法</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">3、坑</a></li>
      <li><a href="#request" id="markdown-toc-request">4、修改request请求头</a></li>
    </ul>
  </li>
  <li><a href="#requesturl" id="markdown-toc-requesturl">5、request.URL重定向</a>    <ul>
      <li><a href="#nsurlprotocolclient" id="markdown-toc-nsurlprotocolclient">6、NSURLProtocolClient</a></li>
    </ul>
  </li>
  <li><a href="#nsurlprotocolnsurlsession" id="markdown-toc-nsurlprotocolnsurlsession">2、NSURLProtocol拦截NSURLSession</a></li>
</ul>

<p>iOS里面总有一些比较神秘，但也总是充满惊喜的API，譬如本博客持续更新的:NSURLProtocol。</p>

<p>NSURLProtocol并不是protocol而是一个虚拟类。使用的话需要实例化一个子类来操作，在这个子类中，可以实现如下的功能，是不是很神奇？</p>

<ul>
  <li>重定向网络请求</li>
  <li>忽略网络请求，使用本地缓存</li>
  <li>自定义网络请求的返回结果</li>
  <li>全局的网络请求设置</li>
</ul>

<p>注意:</p>
<ul>
  <li>NSURLProtocol只能拦截 NSURLConnection、NSURLSession 和 UIWebView 中的请求，无法拦截WKWebView(网络基于WebKit内核)中发出的网络请求。(可使用WKNavigationDelegate处理)</li>
  <li>可以注册多个NSURLProtocol的子类，注册多个NSURLProtocol子类会逆序去执行，也就是先注册的子类后执行。</li>
  <li>AFN\SDWebImage等开始使用NSURLSession，需要注意其中潜在的坑</li>
  <li>UIWebView本身是有缓存的，基于NSURLCache来实现</li>
</ul>

<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">官方文档</a></p>

<p>如下是URL Loading System的组织图，本文只是简单的介绍下NSURLProtocol。</p>

<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="" /></p>

<h2 id="section">1、基本使用</h2>

<h4 id="section-1">1、注册</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    [NSURLProtocol registerClass:[CodeURLProtocol class]];
    return YES;
}
</code></pre>
</div>

<h4 id="section-2">2、实现方法</h4>

<p>// 1、每有一个请求的时候都会调用这个方法，如果返回YES就代表这个request需要被处理，反之就是不需要被处理。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>static NSString * const protocolKey = @"protocolKey";

+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    //防止无限循环，因为一个请求在被拦截处理过程中，也会发起一个请求，这样又会走到这里
    if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) {
        return NO;
    }
    // 对https请求做相关处理
    NSString *scheme = [[request URL] scheme];
    if ([scheme caseInsensitiveCompare:@"https"] == NSOrderedSame) {
        
        return YES;
    }
    return NO;
}
</code></pre>
</div>

<p>// 2、这个方法返回request，一般不做处理直接返回request</p>
<div class="highlighter-rouge"><pre class="highlight"><code>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}
</code></pre>
</div>

<p>///3 这个方法用于处理被拦截的request，拦截请求头、重定向、缓存处理等</p>
<div class="highlighter-rouge"><pre class="highlight"><code>/**
 * 开始请求
 */
- (void)startLoading {
    
}
</code></pre>
</div>

<p>// 4 停止请求</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void) stopLoading {}
</code></pre>
</div>

<h4 id="section-3">3、坑</h4>
<p>不做解释，遇到的人都懂：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) {
    return NO;
}
[NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
</code></pre>
</div>

<h4 id="request">4、修改request请求头</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)startLoading {
    NSMutableURLRequest *request = [self.request mutableCopy];

    //给请求头添加一个请求体
    NSMutableDictionary *headers = [request.allHTTPHeaderFields mutableCopy];
    [headers setObject:@"3code.info" forKey:@"key"];
    request.allHTTPHeaderFields = headers;

    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];

    .....然后使用NSURLSession发送request
}
</code></pre>
</div>
<h2 id="requesturl">5、request.URL重定向</h2>
<p>将请求重定向到3code.info</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
- (void)startLoading {

    NSMutableURLRequest *request = [self.request mutableCopy];
    //request改为访问3code.info了
    request.URL = [NSURL URLWithString:@"http://www.3code.info"];
    
    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request];
    
    //使用NSURLSession继续把重定向的request发送出去
    NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];
    NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
    
    NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:mainQueue];
    
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request];
    
    [task resume];
}
</code></pre>
</div>
<h4 id="nsurlprotocolclient">6、NSURLProtocolClient</h4>

<p>webview中发送一个request，在这里拦截后使用NSURLSession重新发request。那webview是收不到response的。这里就要做一个处理，每一个NSURLProtocol的子类都有一个client对象来处理response。写法用下边这个就行，比较固定的。(保留了以前的NSURLConnection)</p>

<p>本次更新：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    if (error) {
        [self.client URLProtocol:self didFailWithError:error];
    } else {
        [self.client URLProtocolDidFinishLoading:self];
    }
}
-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {
    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
    
    completionHandler(NSURLSessionResponseAllow);
}
-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    [self.client URLProtocol:self didLoadData:data];
}
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
{
    completionHandler(proposedResponse);
}
</code></pre>
</div>
<p>历史记录</p>
<div class="highlighter-rouge"><pre class="highlight"><code>- (void) connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
}
- (void) connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    [self.client URLProtocol:self didLoadData:data];
}
- (void) connectionDidFinishLoading:(NSURLConnection *)connection {
    [self.client URLProtocolDidFinishLoading:self];
}
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
    [self.client URLProtocol:self didFailWithError:error];
}
</code></pre>
</div>

<h2 id="nsurlprotocolnsurlsession">2、NSURLProtocol拦截NSURLSession</h2>

<p>上一期的项目有个需求，就是在移动网络下，不进行高清图片，视频等下载操作。其中遇到的问题就是拦截NSURLSession。这里简化以不下载图片为例，解说如何实现。</p>

<p>思路：使用NSURLProtocol拦截所有的request，过滤耗流量的request。并做处理。其实蛮简单的，但是AFNetwork、SDWebImageCache等三方库并未拦截。原因是NSURLSession。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
+ (BOOL)canInitWithRequest:(NSURLRequest *)request
{
    if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) {
        return NO;
    }
    //满足条件时直接截获请求
    if ([[UserConfig sharedInstance] isOffPicture] &amp;&amp; ([request.URL.pathExtension caseInsensitiveCompare:@"jpg"] == NSOrderedSame || [request.URL.pathExtension caseInsensitiveCompare:@"png"] == NSOrderedSame) &amp;&amp; [self isPictureDownload]) {
        return YES;
    }
    return NO;
}
</code></pre>
</div>

<p>从官方文档中可以了解到自定义的NSURLProtocol子类需要赋给NSURLSessionConfiguration的protocolClasses属性,同时其创建的Session时关联的NSURLSessionConfiguration为defaultSessionConfiguration。那么解决方法就跃然纸上了，如下代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>+ (NSURLSessionConfiguration *)zw_defaultSessionConfiguration{
//    如果需要NSURLProtocol来截获NSURLSession发出的请求，需要每一个NSURLSession在创建时配置的NSURLSessionConfiguration类的protocolClasses属性附上自定义的NSURLProtocol：如下
    
    NSURLSessionConfiguration *configuration = [self zw_defaultSessionConfiguration];
    NSArray *protocolClasses = @[[CodeURLProtocol class]];
    configuration.protocolClasses = protocolClasses;
    
    return configuration;
}
+ (void)load{
//  使用Method Swizzling方法，defaultSessionConfiguration实现（AFNetwork、SDWebImageCache在创建时使用的是[NSURLSessionConfiguration defaultSessionConfiguration]）如下：
    Method systemMethod = class_getClassMethod([NSURLSessionConfiguration class], @selector(defaultSessionConfiguration));
    Method zwMethod = class_getClassMethod([self class], @selector(zw_defaultSessionConfiguration));
    method_exchangeImplementations(systemMethod, zwMethod);
    
    [NSURLProtocol registerClass:[CodeURLProtocol class]];
}

</code></pre>
</div>

<p>以上就解决了NSURLProtocol拦截NSURLSession的问题。</p>


                </div>
                <div class="read-all">
                    <a  href="/2015/10/15/NSURLProtocol/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/10/15/NSURLCache/">NSURLCache缓存的那些事</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-10-15
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#NSURLCache" title="Category: NSURLCache" rel="category">NSURLCache</a>&nbsp;
    
        <a href="/category/#缓存" title="Category: 缓存" rel="category">缓存</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#NSURLCache" title="Tag: NSURLCache" rel="tag">NSURLCache</a>&nbsp;
    
        <a href="/tag/#缓存" title="Tag: 缓存" rel="tag">缓存</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基础篇</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1、扫盲普及</a></li>
      <li><a href="#get-" id="markdown-toc-get-">2、基础：GET 缓存</a></li>
      <li><a href="#post-" id="markdown-toc-post-">3、进阶：POST 缓存</a></li>
      <li><a href="#nsurlcache" id="markdown-toc-nsurlcache">4、进阶：自定义缓存策略的NSURLCache</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">进阶篇</a>    <ul>
      <li><a href="#useprotocolcachepolicy---" id="markdown-toc-useprotocolcachepolicy---">1、UseProtocolCachePolicy - 默认缓存的机制</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2、缓存高清图片</a></li>
    </ul>
  </li>
</ul>

<p>不少的开源项目的网络缓存都是自己家的轮子(譬如AFN俩独立缓存模块：AFAFImagecache (处理image)、NSURLCache(默认URL缓存))，我们现在的项目并未涉及到太复杂的缓存需求，自己造轮子不划算直接用系统的NSURLCache就OK。</p>

<p>在使用中也遇到不少坑：</p>

<ul>
  <li>响应内容过大，不会被缓存；</li>
  <li>Transfer-Encoding: Chunked  分块传输也会导致不缓存。</li>
  <li>…</li>
</ul>

<p>目前在协助子公司开发的一个项目里涉及到各种HTML5中的离线存储需求，实际用的是NSURLProtocol+NSURLCache，根据场景，用两套缓存的方案。对NSURLProtocol感兴趣的可以浏览我的另一篇关于NSURLProtocol的blog。</p>

<h3 id="section">基础篇</h3>

<h4 id="section-1">1、扫盲普及</h4>

<p>1、在iOS中，可以使用NSURLCache类缓存数据，iOS 5之前只支持内存缓存；从iOS 5开始同时支持内存缓存和硬盘缓存；iOS6.0开始，支持HTTPS缓存。</p>

<p>2、缓存分为:内存缓存\硬盘缓存。从app运行角度来说：如果程序没有退出，那么会使用内存中的缓存，如果已经退出重启，则使用硬盘缓存(读取到内存中)。</p>

<p>3、NSURLCache不支持Post请求的缓存处理，GET默认缓存：由于GET请求一般用来查询数据，POST请求一般是发大量数据给服务器处理。因此一般只对GET请求进行缓存，而不对POST请求进行缓存。</p>

<p>4、使用前提：</p>

<ul>
  <li>经常更新：不能用缓存；</li>
  <li>一成不变：果断用缓存；</li>
  <li>偶尔更新：可以定期更改缓存策略或者清除缓存</li>
  <li>GET网络请求、webview页面：果断缓存；</li>
  <li>App离线缓存功能等</li>
</ul>

<p>5、使用也很简单，几行代码搞定：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 1 修改默认的缓存空间：
- (BOOL)application:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
  NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024diskCapacity:20 * 1024 * 1024 diskPath:nil];
  [NSURLCache setSharedURLCache:URLCache];
}
// 2 设置缓存策略：
request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;
OK，搞定。
</code></pre>
</div>
<p>如果不想使用缓存，上边数值设置0即可。</p>

<p>6、缓存的有效性，下文会提到，服务器返回的数据需要一个有效期，过期有效期就得更新本地的缓存。</p>

<h4 id="get-">2、基础：GET 缓存</h4>

<p>1、基本用法:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
（1）获得全局缓存对象 NSURLCache *cache = [NSURLCache sharedURLCache]; 
（2）设置内存缓存的最大容量（字节为单位，默认为512KB）- (void)setMemoryCapacity:
（3）设置硬盘缓存的最大容量（字节为单位，默认为10M）- (void)setDiskCapacity:
（4）硬盘缓存的位置：沙盒/Library/Caches
（5）取得某个请求的缓存- (NSCachedURLResponse *)cachedResponseForRequest:
（6）清除某个请求的缓存- (void)removeCachedResponseForRequest:
（7）清除所有的缓存- (void)removeAllCachedResponses;
</code></pre>
</div>

<p>2、缓存</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
    // 1.创建请求
    NSURL *url = [NSURL URLWithString:@"GET"];
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;
    
    // 2.根据request检测缓存  
    NSURLCache *cache = [NSURLCache sharedURLCache];
    NSCachedURLResponse *response = [cache cachedResponseForRequest:request];
    if (response) {
        NSLog(@"已经有缓存:%@",response.data);
        // 判断时间，超时就移除缓存
    } else {
        NSLog(@"暂无缓存,开启请求");
        [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
         if (data) {
            NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
             NSLog(@"%@", dict);
         }
    }];
    }
    
    
</code></pre>
</div>

<h4 id="post-">3、进阶：POST 缓存</h4>

<p>POST 实现缓存需要自己手动实现，如下解说：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
// 读取缓存
+ (id)getCacheResponseWithURL:(NSString *)url params:(NSDictionary *)params {
    id cacheData = nil;
    if (url) {
        // 指定目录
        NSString *directoryPath = DIRECTORYPATH;
        // url+param确定唯一路径
        NSString *originString = [NSString stringWithFormat:@"%@+%@",url,params];

        NSString *path = [directoryPath stringByAppendingPathComponent:[self md5:originString]];
        NSData *data = [[NSFileManager defaultManager] contentsAtPath:path];
        if (data) {
            cacheData = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        }
    }
    return cacheData;
}
// 写入缓存
+ (void)cacheResponseObject:(id)responseObject request:(NSURLRequest *)request params:(NSDictionary *)params {
    if (request &amp;&amp; responseObject &amp;&amp; ![responseObject isKindOfClass:[NSNull class]]) {
        NSString *directoryPath = DIRECTORYPATH;
        NSError *error = nil;
        if (![[NSFileManager defaultManager] fileExistsAtPath:directoryPath isDirectory:nil]) {
            [[NSFileManager defaultManager] createDirectoryAtPath:directoryPath
                                      withIntermediateDirectories:YES
                                                       attributes:nil
                                                            error:&amp;error];
        }

        NSString *originString = [NSString stringWithFormat:@"%@+%@",request.URL.absoluteString,params];

        NSString *path = [directoryPath stringByAppendingPathComponent:[self md5:originString]];
        NSDictionary *dict = (NSDictionary *)responseObject;

        NSData *data = nil;
        if ([dict isKindOfClass:[NSData class]]) {
            data = responseObject;
        } else {
            data = [NSJSONSerialization dataWithJSONObject:dict
                                                   options:NSJSONWritingPrettyPrinted
                                                     error:&amp;error];
        }
        if (data &amp;&amp; error == nil) {
            [[NSFileManager defaultManager] createFileAtPath:path contents:data attributes:nil];
        }
    }
}
// 加密
+ (NSString *)md5:(NSString *)string {
    if (string == nil || [string length] == 0) {
        return nil;
    }
    unsigned char digest[CC_MD5_DIGEST_LENGTH], i;
    CC_MD5([string UTF8String], (int)[string lengthOfBytesUsingEncoding:NSUTF8StringEncoding], digest);
    NSMutableString *ms = [NSMutableString string];

    for (i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) {
        [ms appendFormat:@"%02x", (int)(digest[i])];
    }

    return [ms copy];
}
</code></pre>
</div>

<h4 id="nsurlcache">4、进阶：自定义缓存策略的NSURLCache</h4>

<p>思路如下：</p>

<ul>
  <li>1、网络请求开始时，首先会判断沙盒中是否存在缓存数据；[没有直接请求]</li>
  <li>2、如果有，判断是否过期；没过期则使用本地数据。[过期则删除缓存，直接请求]</li>
  <li>3、请求URL
代码如下：</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>
// 判断是否为GET
-(NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest*)request{
    if ([request.HTTPMethod compare:@"GET"] != NSOrderedSame) {
        return [super cachedResponseForRequest:request];
    }
    return [self customResponseForRequest:request];
}

// 加密
-(NSString *)getFileName:(NSString *)url{
    return [url getMd5_32Bit];
}

-(NSString *)getOtherInfoName:(NSString *)url{
    return [[NSString stringWithFormat:@"%@-otherInfo",url] getMd5_32Bit];
}
- (NSString *)cacheFilePath:(NSString *)fileName{
    NSString *filePath = [NSString stringWithFormat:@"URLCache/%@",fileName];
    NSString *path = kFilePathAtCachWithName(filePath);
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isDir;
    if([fileManager fileExistsAtPath:path isDirectory:&amp;isDir] &amp;&amp; isDir) {
    } else{
         [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil];
    }
    return path;
}

-(NSCachedURLResponse*)customResponseForRequest:(NSURLRequest*)request{
    ​NSString *url = request.URL.absoluteString;//请求的链接
    
    // URL MD5 后作为缓存文件名。这里取出MD5后的文件名
    NSString*fileName = [self getFileName:url];
    // 缓存信息的文件名 @"%@-otherInfo",url
    NSString*otherInfoName = [self getOtherInfoName:url];
    // 创建/获取 缓存的目录路径
    NSString*filePath = [self cacheFilePath:fileName];
    // 缓存信息字典路径
    NSString*otherInfoPath = [self cacheFilePath:otherInfoName];
    
    ​NSFileManager *fileManger = [NSFileManager defaultManager];
    //当文件存在的时候
    if ([fileManger fileExistsAtPath:filePath]) {
        NSDate*date = [NSDate date];
        BOOL isOverdue = YES;
        NSDictionary *dicInfo = [NSDictionary dictionaryWithContentsOfFile:otherInfoPath];
        // 过期与否？
        if(self.catchTime &gt; 0 &amp;&amp; dicInfo) {
            NSDate*createDate = dicInfo[kTimeKey];
            double createTime = [date timeIntervalSinceDate:createDate];
            if (createTime &lt; self.catchTime) {
                isOverdue = NO;
        }}
        //没有过期 加载缓存数据
        if (!isOverdue) {
            NSLog(@"访问缓存数据..");
            NSData *data = [NSData dataWithContentsOfFile:filePath];
            NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL MIMEType:dicInfo[kMIMETypeKey] expectedContentLength:data.lengthtextEncodingName:dicInfo[kTextEncodingNameKey]];
            NSCachedURLResponse *cacheResponse = [[NSCachedURLResponsealloc] initWithResponse:response data:data];
            return cacheResponse;
            
        }else{//已经过期，删除数据
            [fileManger removeItemAtPath :filePath error:nil];
            [fileManger removeItemAtPath :otherInfoPath error:nil];
        }
    }
    
    BOOL isExsit = [[self.dicResponse objectForKey:url] boolValue];
    if (!isExsit) {
        [self .dicResponse setObject:@(YES) forKey:url];
        NSLog(@"网络请求数据...");
        __block NSCachedURLResponse *cacheResponse = nil;
        [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse*response, NSData *data, NSError *connectionError) {
            //移除请求记录
            [self.dicResponse removeObjectForKey:url];
            if (data &amp;&amp; response) {
                NSMutableDictionary *dicInfo = [NSMutableDictionarydictionary];
                [dicInfo setObject :[NSDate date] forKey:kTimeKey];
                [dicInfo setObject :kUnNilStr(response.MIMEType) forKey:kMIMETypeKey];
                [dicInfo setObject :kUnNilStr(response.textEncodingName) forKey:kTextEncodingNameKey];
                BOOL state = [data writeToFile:filePath atomically:NO];
                NSLog(@"%d",state);
                [dicInfo writeToFile :otherInfoPath atomically:YES];
                cacheResponse = [[NSCachedURLResponse alloc] initWithResponse:response data:data];
            }
        }];
        return cacheResponse;
    }else{
        NSLog(@"该请求已存在");
    }
    return nil;
    
}

</code></pre>
</div>
<h2 id="section-2">进阶篇</h2>

<h4 id="useprotocolcachepolicy---">1、UseProtocolCachePolicy - 默认缓存的机制</h4>

<p>1、首先从apple提供的一个缓存策略的枚举说起：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)
{
    // 默认值：按照HTTP协议进行缓存
    NSURLRequestUseProtocolCachePolicy = 0, 
    // 非缓存模式：不使用缓存数据，无论是否有本地缓存
    NSURLRequestReloadIgnoringLocalCacheData = 1,
    // 缓存模式：无论缓存是否过期都是用缓存，没有缓存就进行网络请求
    NSURLRequestReturnCacheDataElseLoad = 2,
    // 离线模式：无论缓存是否过期都是用缓存，没有缓存也不会进行网络请求
    NSURLRequestReturnCacheDataDontLoad = 3,

    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,
    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented
    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented
};
</code></pre>
</div>
<p>这个枚举大家应该很熟悉，创建request时经常用到的。这里我进行了分类，主要是4类。其余3个排除。这里除了默认值，其他3个模式都很容易理解，下面以QQ空间的web页面拦截为例说明默认值是如何实现的：</p>

<p>2、拦截QQ WebView的请求
首先在webview上加载QQ空间页面，然后拦截webview上QQ空间登录的response，部分Header字段如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
HTTP/1.1 200 OK
Content-Type    application/x-javascript
Server  QZHTTP-2.38.20
Content-Encoding    gzip
Cache-Control   public; max-age=86400
Proxy-Connection    Keep-alive
</code></pre>
</div>
<p>注意：这里的Cache-Control是我们的目标字段。</p>

<p>3、Cache-Control</p>

<p>这个字段用于指定该次整个请求中的缓存机制。常见的取值有public、private、no-cache、max-age、must-revalidate等，默认为private。QQ空间的Cache-Control解读如下：</p>

<ul>
  <li>public : 所有内容都将被缓存(客户端和代理服务器都可缓存)；</li>
  <li>max-age=86400 : 缓存的内容将在86400秒后失效, 这个选项只在HTTP 1.1可用。</li>
</ul>

<p>4、Cache位置</p>

<p>对于webview而言，缓存的数据默认在Library/Caches里。如下所示(ssh连接iphone)</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
# ls
Documents/  Library/  tmp/
# cd Library/ &amp;&amp; ls
2222/  Caches/  Cookies/  Preferences/  WebKit/
# cd Caches/ &amp;&amp; ls

Databases.db                         http_ui.ptlogin2.qq.com_0.localstorage
Snapshots/                           https_auth.alipay.com_0.localstorage
com.apple.WebKit.Networking/         https_passport.jd.com_0/
com.apple.WebKit.WebContent/         https_passport.jd.com_0.localstorage
http_h5.m.taobao.com_0.localstorage  
[截取部分缓存数据]
</code></pre>
</div>

<p>那在app收到response之后，会根据Cache-Control字段，选择缓存的内容以及缓存的时间，而这些缓存的机制则是由服务器端定义。</p>

<h4 id="section-3">2、缓存高清图片</h4>

<p>经常会见到小图点开之后显示高清图片，那实现的一种方式就是:提前缓存高清图片,功能的实现要基于SDWebImage内部缓存的相关接口。</p>

<p>操作如下：拦截response，然后以url为key，数据为value，先缓存起来，在查看大图的时候，直接加载缓存的图片
代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request {
    [super storeCachedResponse:cachedResponse forRequest:request];
    NSString *mimeType = cachedResponse.response.MIMEType;

    if ([mimeType hasPrefix:@"image"]) {
        NSString *url = request.URL.absoluteString;
        NSLog(@"cache url:%@", url);

        SDImageCache *cache = [SDImageCache sharedImageCache];
        [cache storeImage:[UIImage imageWithData:cachedResponse.data] forKey:url toDisk:NO];
    }

}
</code></pre>
</div>
<p>但是注意，这种方法需要URL固定，如果Referer到其他站就会有问题了。</p>

<p>最佳的方案是使用NSURLProtocol解决。详细的可以参考我的NSURLProtocol博文。
如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
- (void)startLoading {
    NSURLSession *session = [NSURLSession sharedSession];
    NSMutableURLRequest *request = [self.request mutableCopy];
    [NSURLProtocol setProperty:@(YES) forKey:kProtocolHandledKey inRequest:request];
    __weak typeof(self) weakSelf = self;
    self.sessionTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        if (error) {
            return;
        }
        NSString *mimeType = response.MIMEType;
        if ([mimeType hasPrefix:@"image"]) {
            NSString *url = weakSelf.request.URL.absoluteString;
            SDImageCache *cache = [SDImageCache sharedImageCache];
            [cache storeImage:[UIImage imageWithData:data] forKey:url toDisk:NO];
        }
        [weakSelf.client URLProtocol:weakSelf didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowedInMemoryOnly];
        [weakSelf.client URLProtocol:weakSelf didLoadData:data];
        [weakSelf.client URLProtocolDidFinishLoading:weakSelf];
    }];
    [self.task resume];
}
- (void)stopLoading {
    [self.sessionTask cancel];
    self.sessionTask = nil;
}

</code></pre>
</div>

<p>我们使用了自定义的NSURLProtocol对所有http(s)请求进行了拦截，并在资源加载完成的时候进行对mime-type的判断，如果是image，那我们就以请求的URL为key，把请求得到的数据转换为UIImage存入SDImageCache中。</p>


                </div>
                <div class="read-all">
                    <a  href="/2015/10/15/NSURLCache/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/08/07/REVERSE_Reveal/">IOS逆向开发系列_Reveal_解码任意APP的UI界面</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-08-07
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#IOS逆向开发" title="Category: IOS逆向开发" rel="category">IOS逆向开发</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Reveal" title="Tag: Reveal" rel="tag">Reveal</a>&nbsp;
    
        <a href="/tag/#iOSOpenDev" title="Tag: iOSOpenDev" rel="tag">iOSOpenDev</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前言</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">关于破解：</a></li>
  <li><a href="#revealloader" id="markdown-toc-revealloader">RevealLoader</a></li>
  <li><a href="#ssh" id="markdown-toc-ssh">SSH</a></li>
  <li><a href="#reveal" id="markdown-toc-reveal">Reveal</a></li>
  <li><a href="#framework---dylib--plist" id="markdown-toc-framework---dylib--plist">framework +  dylib + plist</a>    <ul>
      <li><a href="#revealserverframework" id="markdown-toc-revealserverframework">RevealServer.framework</a></li>
      <li><a href="#librevealdylib" id="markdown-toc-librevealdylib">libReveal.dylib</a>        <ul>
          <li><a href="#iosopendev" id="markdown-toc-iosopendev">方法1：iOSOpenDev创建一个</a></li>
          <li><a href="#section-2" id="markdown-toc-section-2">方法2</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="section">前言</h2>

<p>从最开始写在笔记上的Reveal使用记录，到现在开放到博客，Reveal也历经了好几个版本：1.5.x-&gt;1.6.x-&gt;V++(V2等)。
下边更新了以前写的记录，最近安装Reveal的朋友可以参照此教程。</p>

<h2 id="section-1">关于破解：</h2>

<p>如果是使用1.6.3及以下的版本，可以google到破解文件，覆盖安装就行。
如果是V2及以上版本，破解方法我还没找呢，公司用的是1.6.3版本，家里的就通过修改电脑时间。。
顺便说下，免费使用时长，是可以通过修改电脑日期来调整。这个是我用过的版本里通用的福利方法。。</p>

<p>新版的Reveal上缺少libReaveal.dylib，可以基于Reveal.framwwork使用iOSOpenDev创建一个。</p>

<h2 id="revealloader">RevealLoader</h2>

<p>在手机上添加源:http://rheard.com/cydia</p>

<p>然后安装 Reveal Loader。注意需要VPN才行。</p>

<h2 id="ssh">SSH</h2>

<p>手动开启，或者使用PP助手，没有使用过的话，记得开启后修改密码。</p>

<h2 id="reveal">Reveal</h2>

<p>与其他几个功能相近的工具比如PonyDebugger（https://github.com/square/PonyDebugger）和Spark Inspector（http://sparkinspector.com）相比，最明显的区别就是直观。</p>

<p>其常规用法是将framework集成至Xcode工程中，具体可参见Reveal的官网<a href="http://revealapp.com/">http://revealapp.com/</a>，</p>

<p>下面进重点。</p>

<h2 id="framework---dylib--plist">framework +  dylib + plist</h2>

<h4 id="revealserverframework">RevealServer.framework</h4>
<p>通过openSSH拷贝framework到越狱机</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scp -r /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework root@iphoneip:/System/Library/Frameworks  
</code></pre>
</div>

<p>早期版本的libReveal.dylib是支持ARM架构的，那时，只要把这个libReveal.dylib文件扔到手机的/Library/MobileSubstrate/DynamicLibraries/目录下，就OK了，如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scp /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib root@iphoneip:/Library/MobileSubstrate/DynamicLibraries  
</code></pre>
</div>

<h4 id="librevealdylib">libReveal.dylib</h4>

<p>新版的这个文件是没有的，在早期是有的。麻烦点可以使用iOSOpenDev创建：</p>

<h6 id="iosopendev">方法1：iOSOpenDev创建一个</h6>

<ul>
  <li>1、安装 macports</li>
  <li>2、 已经安装可能要升级,更新MacPorts到最新版本，时间比较长。 $sudo port -v selfupdate</li>
  <li>3、更新MacPorts后，安装DPKG文件，装过的忽略。 $ sudo port -f install dpkg</li>
  <li>4、安装iOSOpenDev <a href="http://iosopendev.com/download/">http://iosopendev.com/download/</a></li>
  <li>5、期间会各种报错，可以google解决。</li>
  <li>6、新建CaptainHookTweak工程，使用Reveal.framwwork生成一个libReaveal.dylib即可。
注意一定要添加相关的库，否则编译会报错。</li>
</ul>

<h6 id="section-2">方法2</h6>

<p>将文件/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer 重命名为libReveal.dylib。copy到手机目录下：/Library/MobileSubstrate/DynamicLibraries/</p>


                </div>
                <div class="read-all">
                    <a  href="/2015/08/07/REVERSE_Reveal/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/08/07/REVERSE_Charles/">IOS逆向开发系列_Charles_iPhone网络抓包</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-08-07
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#IOS逆向开发" title="Category: IOS逆向开发" rel="category">IOS逆向开发</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#Charles" title="Tag: Charles" rel="tag">Charles</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#charles" id="markdown-toc-charles">安装Charles</a></li>
  <li><a href="#section" id="markdown-toc-section">配置</a></li>
</ul>

<h2 id="charles">安装Charles</h2>

<p>官网下载：<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a></p>

<p>从网上找到最新的破解文件：charles.jar，替换系统的即可破解</p>

<h2 id="section">配置</h2>


                </div>
                <div class="read-all">
                    <a  href="/2015/08/07/REVERSE_Charles/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/06/10/WKWebView/">WKWebView使用小结</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-06-10
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#WKWebView" title="Category: WKWebView" rel="category">WKWebView</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#WKWebView、Native与JS交互、离线缓存与NSURLProtocol" title="Tag: WKWebView、Native与JS交互、离线缓存与NSURLProtocol" rel="tag">WKWebView、Native与JS交互、离线缓存与NSURLProtocol</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前言</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">1、基础</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">1.1 初始化</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">1.2 加载页面</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">1.3 协议方法</a>        <ul>
          <li><a href="#section-5" id="markdown-toc-section-5">1.3.1  需要注意的几个协议方法：</a></li>
          <li><a href="#section-6" id="markdown-toc-section-6">1.3.2 其它协议方法汇总</a></li>
        </ul>
      </li>
      <li><a href="#section-7" id="markdown-toc-section-7">1.5 导航刷新相关</a></li>
      <li><a href="#kvo" id="markdown-toc-kvo">1.6 KVO监听标题和进度条</a></li>
    </ul>
  </li>
  <li><a href="#nativejs" id="markdown-toc-nativejs">2、Native与JS的通信</a>    <ul>
      <li><a href="#ios6jsnativeiframe" id="markdown-toc-ios6jsnativeiframe">2.1 iOS6:JS与Native的通信：iFrame</a></li>
      <li><a href="#ios7jsnativejavascriptcore" id="markdown-toc-ios7jsnativejavascriptcore">2.2 iOS7:JS与Native的通信：JavaScriptCore</a></li>
      <li><a href="#ios8jsnativewkscriptmessagehandler" id="markdown-toc-ios8jsnativewkscriptmessagehandler">2.3 iOS8:JS与Native的通信：WKScriptMessageHandler</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">2.4 当然也可以使用三方库 进行通信</a></li>
    </ul>
  </li>
  <li><a href="#nsurlprotocol" id="markdown-toc-nsurlprotocol">3、 缓存与NSURLProtocol</a></li>
  <li><a href="#wkwebview" id="markdown-toc-wkwebview">4、WKWebView的常见问题</a>    <ul>
      <li><a href="#post" id="markdown-toc-post">post请求</a></li>
    </ul>
  </li>
  <li><a href="#section-9" id="markdown-toc-section-9">4、其他</a></li>
</ul>

<h2 id="section">前言</h2>

<p>WKWebView出来有段时间了，项目中一直在使用UIWebView因为要兼容IOS7，前段时间产品那边忽然想开了，ignoreIOS7。于是我们开始使用WkWebView，下边总结了前段时间学习的笔记，记录下来。如果需要demo的还请留言。
早在2014年的WWDC大会上就了解过WebKit，自诩有60fps刷新率、内置手势、和Safari相同的JavaScript引擎等等众多优势，相比之下UIWebview显得比较low。</p>

<p>就这段时间的使用体验来看，变化集中在：</p>
<ul>
  <li>1、内存消耗少；</li>
  <li>2、协议接口更细化，更丰富；</li>
  <li>3、有导航的概览、网站窗口、网站列表等概念；</li>
</ul>

<h2 id="section-1">1、基础</h2>

<p>基本属性</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#import &lt;WebKit/WebKit.h&gt;
WKWebView *webView = [[WKWebView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

// 代理
webView.navigationDelegate = self;
webView.UIDelegate = self;

// opaque不透明的。
webView.opaque = NO;  

// YES证明webView还在加载数据,所有数据加载完毕后,webView就会为No
// webView.loading;

// web内手势左右滑动导航
webView.allowsBackForwardNavigationGestures =YES;

[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.3code.info"]]];
</code></pre>
</div>

<h4 id="section-2">1.1 初始化</h4>

<p>初始化方法，两种：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 默认初始化
- (instancetype)initWithFrame:(CGRect)frame;
// 根据对webview的相关配置，进行初始化
- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;
</code></pre>
</div>

<h4 id="section-3">1.2 加载页面</h4>

<p>// 通过一个网页URL来加载一个WKWebView
-loadRequest: 
// 根据一个文件,加载一个WKWebView，后边是资源路径 【IOS9】
-loadFileURL: allowingReadAccessToURL: 
// 将html文件读取为字符串从而加载为WKWebView，baseURL是我们自己设置的资源路径
-loadHTMLString: baseURL: 
// 下边方法使用的比较少，但更加自由，其中data是文件数据，MIMEType是文件类型，characterEncodingName是编码类型，baseURL是素材资源路径
-(nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL NS_AVAILABLE(10_11, 9_0);</p>

<h4 id="section-4">1.3 协议方法</h4>

<h5 id="section-5">1.3.1  需要注意的几个协议方法：</h5>

<p>1、-(void)webView: decidePolicyForNavigationAction:</p>

<p>注意的是：
A、需要call decisionHandler，允许或者不允许加载，否则报错。
B、
当点击link时，如果有标签_blank,在webview中不会新开窗口，但是在WKWeb中，可以控制新开一个WKWebview。这时可以通过该方法的第一个参数WKNavigationAction的属性，来判断是否需要开新的view:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if(!navigationAction.targetFrame.mainFrame){开新窗口} 这时就会调用 createWebViewWithConfiguration方法return的wkwebview，来加载新的页面。但如果没有实现这个协议，那么操作link就不会有反应了。 我在开发中实际没有用到需要开view的复杂情况，所以我的处理也是简单粗暴，直接处理掉所有的_blank标签。
</code></pre>
</div>

<p>2、-(void) webView: decidePolicyForNavigationResponse: 
这个也需要call decisionHandler,允许or不允许加载。</p>

<h5 id="section-6">1.3.2 其它协议方法汇总</h5>

<div class="highlighter-rouge"><pre class="highlight"><code>
/* WKNavigationDelegate  */

//1、【即将发送request请求】 可以决定是否请求，拦截request、cookie等。call decisionHandler
- (void)webView: decidePolicyForNavigationAction: 
//2、【开始请求页面】
- (void)webView: didStartProvisionalNavigation: 
//3、【收到response】 根据response决定要不要继续加载。call decisionHandler
-(void) webView: decidePolicyForNavigationResponse: 
//4、【收到web内容，开始渲染】 可以注入JS
- (void)webView: didCommitNavigation: 
//5、【页面渲染完成】可以注入JS
- (void)webView: didFinishNavigation: 

// 【网页内容被终止】
- (void)webViewWebContentProcessDidTerminate:
// 【错误：页面跳转失败】
- (void)webView: didFailNavigation: 
// 【错误：启动加载数据失败】
- (void)webView: didFailProvisionalNavigation: 
// 【页面校验身份】
- (void)webView: didReceiveAuthenticationChallenge: 
// 【重定向】
- (void)webView: didReceiveServerRedirectForProvisionalNavigation
 

/* UIDelegate  */
当页面中有调用了js的alert、confirm、prompt方法就会触发以下方法
// 页面中有输入框弹出警告框时调用
- (void)webView: runJavaScriptTextInputPanelWithPrompt: 
// 页面中有确认框弹出警告框时调用
- (void)webView: runJavaScriptConfirmPanelWithMessage:( 
// 警告框页面中有警告框弹出警告框时调用
- (void)webView: runJavaScriptAlertPanelWithMessage: 

</code></pre>
</div>

<h4 id="section-7">1.5 导航刷新相关</h4>

<p>网页导航刷新相关函数和UIWebview几乎一样，不同的是增加了函数reloadFromOrigin和goToBackForwardListItem。</p>

<p>//会比较网络数据是否有变化，没有变化则使用缓存，否则从新请求。
-(WKNavigation *)reloadFromOrigin;</p>

<p>//比向前向后更强大，可以跳转到某个指定历史页面
-(WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;</p>

<h4 id="kvo">1.6 KVO监听标题和进度条</h4>

<p>可以利用title和estimatedProgress，用KVO去监听，实时改变进度和标题:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[self.webView addObserver:self forKeyPath:@"title" options:NSKeyValueObservingOptionNew context:NULL];
[self.webView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:NULL];

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if ([keyPath isEqualToString:@"estimatedProgress"] &amp;&amp; object == self.webView) {
        [self.progress setAlpha:1.0f];
        [self.progress setProgress:self.webView.estimatedProgress animated:YES];
        
        if(self.webView.estimatedProgress &gt;= 1.0f) {
            [UIView animateWithDuration:0.3 delay:0.3 options:UIViewAnimationOptionCurveEaseOut animations:^{
                [self.progress setAlpha:0.0f];
            } completion:^(BOOL finished) {
                [self.progress setProgress:0.0f animated:NO];
            }];
        }
    }
    else if ([keyPath isEqualToString:@"title"] &amp;&amp; object == self.webView) {
            NSString * titleText = self.webView.title;
            self.title = titleText; 
    } else {
            [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
        }
}

注意：移除掉观察者
 [self.webView removeObserver:self forKeyPath:@"title"];
 [self.webView removeObserver:self forKeyPath:@"estimatedProgress"];

</code></pre>
</div>

<h2 id="nativejs">2、Native与JS的通信</h2>

<p>几点注意：</p>

<p>1、线程方面需要注意的是:</p>
<ul>
  <li>iframe调用Navite是异步执行的(android中是同步的)；</li>
  <li>stringByEvaluatingJavaScriptFromString是同步执行的；</li>
</ul>

<p>2、编码方面：</p>
<ul>
  <li>通信过程中，从JS向Native传递可能会出现乱码情况，最好进行Base64编码然后附加在url后面进行传递</li>
  <li>Native调用JS需要在页面加载完成之后进行；</li>
  <li>键盘的控制不好处理: [obj becomeFirstResponder]方法不可用</li>
</ul>

<h4 id="ios6jsnativeiframe">2.1 iOS6:JS与Native的通信：iFrame</h4>

<p>iOS6原生没有提供js直接调用Objective-C的方式，只能通过UIWebView的UIWebViewDelegate协议拦截iframe请求实现。</p>

<p>1、Native调用JS  stringByEvaluatingJavaScriptFromString:</p>

<p>如果需要OC给JS回调，也用这个方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>NSString *jsString = @" var p = document.createElement('p'); \
                        p.innerText = 'New page';            \
                        document.body.appendChild(p);        \
";
[_webView stringByEvaluatingJavaScriptFromString:jsString];
</code></pre>
</div>

<p>2、JS调用Native  webView:shouldStartLoadWithRequest:</p>

<p>JS中：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>    function loadURL(url) {
        var iFrame;
        iFrame = document.createElement("iframe");
        iFrame.setAttribute("src", url);
        iFrame.setAttribute("style", "display:none;");
        iFrame.setAttribute("height", "0px");
        iFrame.setAttribute("width", "0px");
        iFrame.setAttribute("frameborder", "0");
        document.body.appendChild(iFrame);
        // 发起请求后这个iFrame就没用了，从dom上移除掉
        iFrame.parentNode.removeChild(iFrame);
        iFrame = null;
    }
比如我们在js代码中，调用js方法：
    function iOS_alert() {//调用自定义对话框
        //window.location.href调用的话会导致前一次操作取消
        loadURL("alert://baidu");
    }
    // 以下是为了解决OC回调给JS时候，可能存在的阻塞主线程情形。可以结合实际决定要不要使用。
    function asyncAlert(content) {
    setTimeout(function(){
               alert(content);
               },1);
    }
    function setLocation(location) {
        asyncAlert(location);
        document.getElementById("Value").value = location;
    }

</code></pre>
</div>

<p>Native中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// url.scheme 区分是不是我要拦截的，url.host决定调用哪个方法。
//return YES则会加载URL，NO不加载URL
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{
    NSURL * url = [request URL];
    if ([[url scheme] isEqualToString:@"alert"]) {//拦截alert
        UIAlertView * alertView = [[UIAlertView alloc] initWithTitle:@"test" message:[url host] delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
        [alertView show];
        return NO;
    }
    return YES;
}
</code></pre>
</div>

<h4 id="ios7jsnativejavascriptcore">2.2 iOS7:JS与Native的通信：JavaScriptCore</h4>

<p>iOS7中加入了JavaScriptCore.framework框架。把WebKit的JavaScript引擎用OC 封装。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单。</p>

<p>1、JS调用Native
JS中：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;button type="button" onclick="showAlert('YES')"&gt;Click&lt;/button&gt;
function showAlert(msg){
            alert(msg);
        }
</code></pre>
</div>
<p>Native中：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];

- (void)webViewDidFinishLoad:(UIWebView *)webView {
    JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
    //定义好JS要调用的方法, alert就是方法名
    context[@"alert"] = ^() {
        NSArray *args = [JSContext currentArguments];
        UIAlertView *alertView = [[UIAlertView alloc] init
        [alertView show];
        
        for (JSValue *jsVal in args) {
            NSLog(@"%@", jsVal.toString);
        }
    };
}

</code></pre>
</div>

<p>2、OC调用JS</p>

<p>方法1：stringByEvaluatingJavaScriptFromString:不过该方法是同步执行的，可能会阻塞UI的刷新。</p>

<p>方法2： -evaluateScript</p>

<div class="highlighter-rouge"><pre class="highlight"><code>JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
NSString *textJS = @"showAlert('弹出message')";
[context evaluateScript:textJS]; 方法3： -callWithArguments

JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
[context[@"payResult"] callWithArguments:@[@"支付结果"]];
</code></pre>
</div>

<p>需要注意的是:WKWebView不支持通过如下的KVC的方式创建JSContext：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
</code></pre>
</div>

<p>在WKWebView中有OC和JS交互的方式，更简洁，因此JavaScriptCore对我来说是昙花一现，基本不使用的。</p>

<h4 id="ios8jsnativewkscriptmessagehandler">2.3 iOS8:JS与Native的通信：WKScriptMessageHandler</h4>

<p>1、JS调用Native：</p>

<p>注入JS</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// 除了和UIWebView加载一个隐藏的ifame之外，WKWebView自身还提供了一套js调用native的方法,如下：

// 创建配置
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
// 提供javaScript向webView发送消息的方法
 WKUserContentController *userContent = [[WKUserContentController alloc] init];
// 注入JS对象：NativeMethod，注意：self需要遵守WKScriptMessageHandler协议，结束时需要移除
[userContent addScriptMessageHandler:self name:@"NativeMethod"];
// 将UserContentController设置到配置文件中
config.userContentController = userContent;
// 自定义配置创建WKWebView
WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];
</code></pre>
</div>

<p>Native拦截JS</p>
<div class="highlighter-rouge"><pre class="highlight"><code>- (void)userContentController:(WKUserContentController *)userContentController
      didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@"NativeMethod"]) {
        NSLog(@"message.body:%@", message.body);
        //如果是自己定义的协议, 再截取协议中的方法和参数, 判断无误后在这里手动调用oc方法
        NSMutableDictionary *param = [self queryStringToDictionary:message.body];
        NSLog(@"get param:%@",[param description]);
        
        NSString *func = [param objectForKey:@"func"];
        
        //调用本地函数
        if([func isEqualToString:@"alert"])
        {
            [self showMessage:@"来自网页的提示" message:[param objectForKey:@"message"]];
        }
     
    }
}
</code></pre>
</div>
<p>// 注意decisionHandler必须执行。</p>

<p>2、Native调用JS：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler;
//使用，同上webview
NSString *jsString = @" var p = document.createElement('p'); \
                        p.innerText = 'New Line';            \
                        document.body.appendChild(p);        \
";
[_wkView evaluateJavaScript:jsString completionHandler:^(id item, NSError *error) {
// 这里是回调的结果
}];
</code></pre>
</div>

<p>//completionHandler 拥有两个参数，一个是返回错误，一个可以返回执行脚本后的返回值，</p>

<h4 id="section-8">2.4 当然也可以使用三方库 进行通信</h4>

<h2 id="nsurlprotocol">3、 缓存与NSURLProtocol</h2>

<p>WKWebView的请求不能被NSURLProtocol截获。而我们团队开发的app中对于H5容器最佳的优化点主要就在于使用NSURLProtocol技术对于H5进行离线包的处理和H5的图片和Native的图片公用一套缓存的技术。因为该问题的存在，目前我们团队还没有使用WKWebView代替UIWebVIew。</p>

<p>在UIWebView，使用NSURLCache缓存，通过setSharedURLCache可以设置成我们自己的缓存，但WKWebView不支持NSURLCache。所以涉及到离线缓存的问题时，要注意区分使用哪个。</p>

<h2 id="wkwebview">4、WKWebView的常见问题</h2>

<p>崩溃问题: Terminating app due to uncaught exception ‘NSInternalInconsistencyException’ reason: ‘Completion handler passed to - [ViewController webView: decidePolicyForNavigationAction: decisionHandler:] was not called’
解决办法: 在webView:decidePolicyForNavigationAction:decisionHandler:函数里需执行decisionHandler的block</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
- (void)webView:(WKWebView*)webView decidePolicyForNavigationAction:(WKNavigationAction*)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
{
    if (navigationAction.navigationType == WKNavigationTypeLinkActivated) {
        decisionHandler(WKNavigationActionPolicyAllow);
    }
    else {
        decisionHandler(WKNavigationActionPolicyCancel);
    }
}
</code></pre>
</div>

<h4 id="post">post请求</h4>

<p>在Native中使用WKWeb发送POST暂时不支持的，需要通过JS走：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;script&gt;
         //调用格式： post('URL', {"key": "value"});
         function post(path, params) {
             var method = "post";
             var form = document.createElement("form");
             form.setAttribute("method", method);
             form.setAttribute("action", path);

             for(var key in params) {
                 if(params.hasOwnProperty(key)) {
                     var hiddenField = document.createElement("input");
                     hiddenField.setAttribute("type", "hidden");
                     hiddenField.setAttribute("name", key);
                     hiddenField.setAttribute("value", params[key]);

                     form.appendChild(hiddenField);
                 }
             }
             document.body.appendChild(form);
             form.submit();
         }
     &lt;/script&gt;
</code></pre>
</div>
<p>然后在- (void)webView: didFinishNavigation: 中调用如下代码：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
     if (self.ONCE) {
         // 调用使用JS发送POST请求的方法
         [self postRequestWithJS];
         // 将Flag置为NO（后面就不需要加载了）
         self.needLoadJSPOST = NO;
     }
 }
 // 调用JS发送POST请求
 - (void)postRequestWithJS {
     // 发送POST的参数
     NSString *postData = @"\"username\":\"aaa\",\"password\":\"123\"";
     // 请求的页面地址
     NSString *urlStr = @"http://www.baidu.com";
     // 拼装成调用JavaScript的字符串
     NSString *jscript = [NSString stringWithFormat:@"post('%@', /\%\}/@});", urlStr, postData];
     // NSLog(@"Javascript: %@", jscript);
     // 调用JS代码
     [self.webView evaluateJavaScript:jscript completionHandler:^(id object, NSError * _Nullable error) {

     }];
 }
</code></pre>
</div>

<h2 id="section-9">4、其他</h2>

<p>iOS Xcode工程目录的 folder 和 group的区别(蓝色和黄色文件夹的区别)：</p>

<p>group 一般只在你的工程中是文件夹的形式，但是在本地的目录中还是以散乱的形式放在一起的，除非你是从外部以group的形式引用进来的。</p>

<p>folder 只能作为资源，整个引用进项目，不能编译代码，也就是说，以folder形式引用进来的文件，不能被放在complie sources列表里面。</p>

<p>从外部拖入文件时，
选择Creat Groups：文件夹黄色的 <br />
Creat Floder：这里我选择的是以folder的形式引用文件夹，点击完成，如下图所示，文件夹是蓝色的</p>


                </div>
                <div class="read-all">
                    <a  href="/2015/06/10/WKWebView/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2015/05/05/macServe/">在mac上开启http服务</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2015-05-05
                    </div>
                    <div class="label-card">
                        <i class="fa fa-user"></i>3行代码
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#apache" title="Category: apache" rel="category">apache</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#apache" title="Tag: apache" rel="tag">apache</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    

                </div>
                <div class="read-all">
                    <a  href="/2015/05/05/macServe/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <a href="/index.html" class="previous"><i class="fa fa-angle-double-left"></i></a>
            <a href="/page3" class="previous"><i class="fa fa-angle-left"></i></a>
          
          <span class="page_number ">4/5</span>
          
            <a href="/page5" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page5" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    最新文章
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2016/11/10/pythonGetFund/">python脚本 - 开机自动爬基金数据</a></li>
                    
                        <li><a href="/2016/11/07/Runtime-theory/">IOS逆向开发系列7_IOS理论基础</a></li>
                    
                        <li><a href="/2016/11/06/TaoBao/">淘宝和12306的那些事</a></li>
                    
                        <li><a href="/2016/11/05/IOS_Adopt/"> 一道面试题里藏的IOS世界</a></li>
                    
                        <li><a href="/2016/11/01/7_IOS_Reverse_Theory/">IOS逆向开发系列7_IOS理论基础</a></li>
                    
                        <li><a href="/2016/11/01/6_IOS_Tools/">IOS逆向开发系列6_IOS工具集</a></li>
                    
                        <li><a href="/2016/11/01/5_IDA-iFunBox-other/">IOS逆向开发系列5_IDA/iFunBox/other</a></li>
                    
                        <li><a href="/2016/11/01/4_Reveal/">IOS逆向开发系列4_Reveal</a></li>
                    
                        <li><a href="/2016/11/01/3_Theos_-fourFile/">IOS逆向开发系列3_Theos_file简介及Logos基本语法</a></li>
                    
                        <li><a href="/2016/11/01/2_Theos_-install&run/">IOS逆向开发系列2_Theos_安装编译打包运行</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    分类
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#block" class="categories-list-item" cate="block">
                            <span class="name">
                                block
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#iOS动画" class="categories-list-item" cate="iOS动画">
                            <span class="name">
                                iOS动画
                            </span>
                            <span class="badge">4</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#CALayer" class="categories-list-item" cate="CALayer">
                            <span class="name">
                                CALayer
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#apache" class="categories-list-item" cate="apache">
                            <span class="name">
                                apache
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#WKWebView" class="categories-list-item" cate="WKWebView">
                            <span class="name">
                                WKWebView
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IOS逆向开发" class="categories-list-item" cate="IOS逆向开发">
                            <span class="name">
                                IOS逆向开发
                            </span>
                            <span class="badge">11</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#NSURLCache" class="categories-list-item" cate="NSURLCache">
                            <span class="name">
                                NSURLCache
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#缓存" class="categories-list-item" cate="缓存">
                            <span class="name">
                                缓存
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#NSURLProtocol" class="categories-list-item" cate="NSURLProtocol">
                            <span class="name">
                                NSURLProtocol
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#缓存~~~" class="categories-list-item" cate="缓存~~~">
                            <span class="name">
                                缓存~~~
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#SecureCRT" class="categories-list-item" cate="SecureCRT">
                            <span class="name">
                                SecureCRT
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#博客" class="categories-list-item" cate="博客">
                            <span class="name">
                                博客
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#jekyll" class="categories-list-item" cate="jekyll">
                            <span class="name">
                                jekyll
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#OS_X" class="categories-list-item" cate="OS_X">
                            <span class="name">
                                OS_X
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#Sublime" class="categories-list-item" cate="Sublime">
                            <span class="name">
                                Sublime
                            </span>
                            <span class="badge">2</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#IOS基础" class="categories-list-item" cate="IOS基础">
                            <span class="name">
                                IOS基础
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#杂谈" class="categories-list-item" cate="杂谈">
                            <span class="name">
                                杂谈
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#python" class="categories-list-item" cate="python">
                            <span class="name">
                                python
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                      
                      
                      
                      
                      
                      <a href="/tag/#block" style="font-size: 9pt; color: #999;">block</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOS动画" style="font-size: 18pt; color: #000;">iOS动画</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#CADisplayLink" style="font-size: 15pt; color: #333;">CADisplayLink</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#CALayer" style="font-size: 9pt; color: #999;">CALayer</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#apache" style="font-size: 9pt; color: #999;">apache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#WKWebView、Native与JS交互、离线缓存与NSURLProtocol" style="font-size: 9pt; color: #999;">WKWebView、Native与JS交互、离线缓存与NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Charles" style="font-size: 9pt; color: #999;">Charles</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Reveal" style="font-size: 12pt; color: #666;">Reveal</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iOSOpenDev" style="font-size: 9pt; color: #999;">iOSOpenDev</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLCache" style="font-size: 9pt; color: #999;">NSURLCache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#缓存" style="font-size: 12pt; color: #666;">缓存</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#NSURLProtocol" style="font-size: 9pt; color: #999;">NSURLProtocol</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#SecureCRT" style="font-size: 9pt; color: #999;">SecureCRT</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#博客" style="font-size: 9pt; color: #999;">博客</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#jekyll" style="font-size: 9pt; color: #999;">jekyll</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#sublime" style="font-size: 9pt; color: #999;">sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#环境变量" style="font-size: 9pt; color: #999;">环境变量</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Sublime" style="font-size: 12pt; color: #666;">Sublime</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS逆向开发" style="font-size: 9pt; color: #999;">IOS逆向开发</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#class_dump" style="font-size: 9pt; color: #999;">class_dump</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Theos" style="font-size: 12pt; color: #666;">Theos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#Logos" style="font-size: 9pt; color: #999;">Logos</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IDA" style="font-size: 9pt; color: #999;">IDA</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iFunBox" style="font-size: 9pt; color: #999;">iFunBox</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#dyld_decache" style="font-size: 9pt; color: #999;">dyld_decache</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#逆向_IOS工具集" style="font-size: 9pt; color: #999;">逆向_IOS工具集</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS逆向开发理论基础" style="font-size: 12pt; color: #666;">IOS逆向开发理论基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS代码规范" style="font-size: 9pt; color: #999;">IOS代码规范</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#IOS基础" style="font-size: 9pt; color: #999;">IOS基础</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#淘宝" style="font-size: 9pt; color: #999;">淘宝</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#12306" style="font-size: 9pt; color: #999;">12306</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#爬基金数据" style="font-size: 9pt; color: #999;">爬基金数据</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#脚本" style="font-size: 9pt; color: #999;">脚本</a>
                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             3行代码的技术博客 
        </p>
        <p class="contact">
            Contact me at:  
            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>   -->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>-->
<!--            <a href="mailto:mythziven@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>        -->


        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
        
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>

          <!--   <span>
                Theme designed by <a href="https://github.com/mythkiven">MyKiven</a>.
            </span> -->

        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
  </body>

</html>
